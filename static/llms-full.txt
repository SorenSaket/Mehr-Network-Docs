# Mehr Network — Complete Documentation

> Decentralized mesh networking infrastructure powered by Proof of Service.
> Source: https://mehr.network
> Generated: 2026-03-02

---

# Overview

## Introduction
<!-- Source: docs/introduction.md -->



# Mehr Network

**Decentralized Mesh Infrastructure Powered by Proof of Service**

Proof of work wastes electricity. Proof of stake rewards capital, not contribution. Mehr uses **proof of service** — a token is minted only when a real service is delivered to a real paying client through a funded payment channel. Relay a packet, store a block, run a computation — that's how MHR enters circulation. No work is wasted. No token is unearned.

Mehr is a decentralized network where every resource — bandwidth, compute, storage, connectivity — is a discoverable, negotiable, verifiable, payable capability. Nodes participate at whatever level their hardware allows. Nothing is required except a cryptographic keypair.

## The State of the World

The internet depends on centralized infrastructure: ISPs, cloud providers, DNS registrars, certificate authorities. Every packet, every query, every byte passes through chokepoints owned by a small number of corporations. When any of these fail — through censorship, natural disaster, corporate decision, or economic exclusion — people lose connectivity entirely. The architecture has a single point of failure, and that point is someone else's business model.

The concentration is accelerating. Hyperscale data centers now account for 44% of global data center capacity, up from under 30% five years ago. Three cloud providers control 63% of the cloud infrastructure market. AI has made it worse — a single training run requires 15,000–25,000 advanced GPUs at a cost of $120M–$450M. NVIDIA controls 80–92% of the AI accelerator market. The specialized memory these chips require (HBM) is manufactured by exactly three companies, with the entire supply sold out years in advance. The ability to compute is being gatekept at the hardware level, and the gate is narrowing.

The internet was supposed to connect people. Instead, it routed everything through distant data centers and handed control to platforms that optimize for engagement, not truth or community. Algorithmic feeds decide what you see. You know more about celebrities than what's happening on your own street. Your neighbor could be building something extraordinary and you'd never hear about it. The infrastructure that was meant to strengthen communities instead bypasses them entirely.

Governments can shut down the internet with a phone call to a handful of ISPs. When all communication passes through centralized chokepoints, censorship is trivial. A country can be disconnected from the world — or from itself — overnight. Communities that depend entirely on infrastructure they don't own have no fallback when that infrastructure is turned against them.

Most hardware sits idle most of the time. A home internet connection averages below 5% utilization. A desktop GPU sits unused 22 hours a day. A neighborhood full of powerful devices amounts to a distributed supercomputer that nobody can use, because there's no way to share it. People pay full price for dedicated connections and hardware that mostly does nothing.

Decentralized networks were supposed to fix this. They haven't. Proof of Work concentrates around cheap electricity and specialized hardware — six mining pools mine over 95% of all Bitcoin blocks. Proof of Stake concentrates around existing capital — whale wallets hold 57% of Ethereum's supply, and the compounding effect makes wealth concentration self-reinforcing. Decentralized compute projects re-centralize through "Nodekeepers" and whale wallets. The pattern is consistent: when all compute is valued equally regardless of location, capital concentration wins.

## Goals

### Strengthen Communities

Communication within a community is free, direct, and unstoppable. Trusted neighbors relay for each other at zero cost. The economic layer only activates when traffic crosses trust boundaries — just like the real world, where you help your neighbors for free but charge strangers for using your infrastructure. The network makes local connections stronger, not routes around them.

### Democratize Infrastructure

A village with no ISP can still communicate. A country under internet shutdown still has a mesh. A community that can't afford $30/month per household shares one uplink across a neighborhood. Communication infrastructure is a commons, not a product. Any medium that can move bytes — from 500 bps radio to 10 Gbps fiber — is a valid link. Every device contributes what it can and pays for what it needs. Hardware determines capability; the market determines role.

### Distribute Power

Compute, storage, and bandwidth are not gatekept by whoever can build the biggest data center. A solar-powered relay on a rooftop serving its neighborhood earns based on the traffic it carries, not the capital behind it. Proximity to demand — not capital — determines value. A GPU in your neighbor's garage is cheaper to use than a GPU farm across the continent. The network structurally resists concentration, not reproduces it.

### Waste Nothing

Idle hardware becomes shared infrastructure. Your phone delegates AI inference to a neighbor's GPU. Your Raspberry Pi stores data for the mesh. Communities need far less total hardware to achieve the same capabilities — you earn when others use your resources, and you pay when you use theirs.

### Privacy as Default

Packets carry no source address. A relay node knows which neighbor handed it a packet, but not whether that neighbor originated it or is relaying it from someone else. Identity is a cryptographic keypair — not a name, not an IP address, not an account. Human-readable names are optional and trust-scoped. You decide what to reveal and to whom. This does not conflict with paid relay — [payment channels](/docs/L3-economics/payment-channels#bilateral-payment-channels) are per-hop bilateral, so each relay settles with its direct neighbor without ever learning the end-to-end path.

### Partition Tolerance

Network fragmentation is not an error state — it is expected operation. A village on LoRa is a partition. A country with its internet cut is a partition. Every protocol layer functions correctly during partitions and converges correctly when partitions heal. The ledger compacts, the routing adapts, and the economics bound any damage to a predictable amount.

## What Makes Mehr Different

### Capability Marketplace

Nodes advertise what they can do. What they cannot do, they delegate to a neighbor and pay for the service. [Service discovery](/docs/L4-marketplace/discovery) uses concentric rings so most requests resolve locally — your storage request finds a nearby provider before it ever discovers a distant data center. [Agreements](/docs/L4-marketplace/agreements) are bilateral contracts between provider and client, and [verification](/docs/L4-marketplace/verification) is cryptographic. A $30 solar relay and a GPU workstation participate on equal terms; the network routes requests to whoever can serve them best for the lowest cost.

### Proof of Service

Most decentralized networks create tokens through artificial work (hashing) or capital lockup (staking). Mehr mints tokens only when a provider delivers a real service — relaying traffic, storing data, or executing computations — to a client who pays through a funded payment channel. Minting is proportional to real economic activity and capped at 50% of net service income. A 2% burn on every payment creates a deflationary counterforce that keeps supply bounded.

### Zero Trust Economics

The economic layer assumes every participant is adversarial. Two mechanisms make cheating structurally unprofitable: **non-deterministic service assignment** (the client can't choose who serves the request) and a **net-income revenue cap** (cycling MHR produces zero minting). No staking, no slashing, no trust scores required. In isolated partitions, [additional defense layers](/docs/L3-economics/token-security#attack-isolated-partition) bound damage to a predictable amount — even an infinitely long 3-node partition produces less than 1.5% total supply dilution.

### Free Between Friends

Nodes maintain [trust neighborhoods](/docs/L3-economics/trust-neighborhoods) — sets of peers they relay for at zero cost. No tokens, no channels, no economic overhead. A local mesh where everyone trusts each other operates without the economic layer even activating. The boundary between free and paid is not set by the protocol — it emerges from each community's own trust relationships.

### Self-Sovereign Identity

Your identity is your cryptographic key — not an account on someone else's server. [MHR-ID](/docs/L5-services/mhr-id) lets you build a rich profile (name, bio, avatar, linked accounts, achievements) where every field is a signed claim that peers can vouch for or dispute. You control who sees each field: public, trusted friends only, friends-of-friends, or specific people. No central identity provider. No data broker.

### Subjective Naming

There is no global DNS. [MHR-Name](/docs/L5-services/mhr-name) provides human-readable names (`alice@geo:portland`, `my-blog@topic:tech`) that resolve from each viewer's position in the trust graph. Names registered by people you trust outrank names from strangers. Two communities can have different "alice" users — that's by design. Names can point to people, content, or [distributed applications](/docs/L5-services/mhr-app).

### Distributed Applications

Applications on Mehr are not hosted on servers — they are [content-addressed packages](/docs/L5-services/mhr-app) stored in the mesh. An AppManifest bundles contract code, UI, state schema, and dependencies into a single installable artifact. Users discover apps by name, install them locally, and upgrade via trust-weighted update propagation. No app store. No platform fee. No single point of removal.

## Protocol Stack Overview

Mehr is organized into seven layers, each building on the one below. Each layer depends only on the layer below it — applications never touch transport details, payment never touches routing internals, and security is structural, not bolted on. Click any layer to read its full specification.


## How It Works — A Simple Example

1. **Alice** has a Raspberry Pi with a LoRa radio and WiFi. She's in a rural area with no internet. She's registered as `alice@geo:us/oregon/bend` and her profile shows her bio, avatar, and a verified GitHub link.
2. **Bob** has a gateway node 5 km away with a cellular modem providing internet access. He's Alice's trusted peer — they relay for each other for free.
3. **Carol** is somewhere on the internet and wants to message Alice.

Here's what happens:

- Carol looks up `alice@geo:us/oregon/bend` — the name resolves to Alice's node via trust-weighted resolution
- Carol's message is encrypted end-to-end for Alice's public key
- It routes through the internet to Bob's gateway
- Bob relays it over LoRa to Alice (free, because Alice is his trusted peer)
- Alice's device decrypts and displays the message
- Carol's relay cost to reach Bob's gateway is paid automatically through a bilateral payment channel

Carol can see Alice's public profile fields (bio, avatar, verified GitHub) but not her phone number — Alice set that to DirectTrust visibility, so only her trusted peers can see it.

No central server. No accounts. No subscriptions. Just cryptographic identities, trust-weighted naming, and a marketplace for capabilities.

## Next Steps

- **Understand the protocol**: Start with [Physical Transport](/docs/L0-physical/physical-transport) and work up the stack
- **Explore the economics**: Learn how [MHR tokens](/docs/L3-economics/mhr-token) and [stochastic relay rewards](/docs/L3-economics/payment-channels) enable decentralized resource markets
- **Identity and naming**: See how [MHR-ID](/docs/L5-services/mhr-id) builds self-sovereign profiles and how [MHR-Name](/docs/L5-services/mhr-name) provides trust-weighted naming
- **Distributed apps**: Learn how [AppManifests](/docs/L5-services/mhr-app) package and distribute applications across the mesh
- **See the real-world impact**: Understand [how Mehr affects existing economics](/docs/L3-economics/real-world-impact) and how participants earn
- **See the hardware**: Check out the [reference designs](hardware/reference-designs) for building Mehr nodes
- **Read the full spec**: The complete [protocol specification](specification) covers every detail

---

## FAQ
<!-- Source: docs/faq.md -->

# Frequently Asked Questions

Plain-language answers. No jargon.

## The Basics

<details className="faq-item">
<summary>What is Mehr?</summary>

Mehr is a communication network that doesn't need the internet, phone towers, or any central service. Devices talk directly to each other using radios (LoRa, WiFi, Bluetooth) and relay messages through the mesh — like passing a note through friends until it reaches the person you want.

There's no company in the middle. No account to create. No server to depend on. Your identity is a cryptographic key pair — you generate it on your device, and that's it. See [Introduction](introduction) for the full overview.

</details>

<details className="faq-item">
<summary>How do I join?</summary>

Get a device (even just a phone), install the Mehr app, and power it on. Your device generates a cryptographic identity and starts discovering nearby nodes. There's no sign-up, no email, no phone number required.

To become part of a community, mark your neighbors as trusted — and have them mark you as trusted. That's it. The trust graph *is* the network.

</details>

<details className="faq-item">
<summary>What device do I need?</summary>

Anything from a $5 ESP32 module to a full desktop. The protocol adapts to what you have:

| Device | What It Does |
|--------|-------------|
| ESP32 + LoRa ($5–15) | Basic radio relay — extends mesh coverage |
| Raspberry Pi ($35–50) | Full node — relay, storage, naming, routing |
| Android phone | All services + UI — messaging, social, voice |
| Desktop/server | High-capacity relay, storage provider, compute provider |

See [Device Tiers](hardware/device-tiers) for detailed specifications per tier.

</details>

<details className="faq-item">
<summary>Is it free?</summary>

Talking to your trusted peers (friends, family, neighbors) is always free — no tokens, no fees. This is the [trust neighborhoods](/docs/L3-economics/trust-neighborhoods) model: if you trust someone, relaying their traffic costs you nothing.

When your traffic crosses through strangers' infrastructure — people you don't know, who have no reason to carry your traffic for free — that costs a small amount of [MHR tokens](/docs/L3-economics/mhr-token). You earn tokens by relaying traffic for others, so for most users the system balances out: you earn by participating and spend by using.

</details>

<details className="faq-item">
<summary>Do I need to buy tokens?</summary>

No. You earn MHR automatically by relaying traffic and providing services. A device that's turned on and connected earns tokens passively. If you don't want to deal with tokens at all, a [gateway operator](/docs/L3-economics/token-economics#gateway-operators-fiat-onramp) can handle it — you pay a small monthly fee (in regular money) and they take care of the crypto side.

</details>

---

## Finding Things

<details className="faq-item">
<summary>How do I find local news and events?</summary>

Content on Mehr is tagged with [geographic scopes](/docs/L3-economics/trust-neighborhoods#hierarchical-scopes) — like `geo:us/or/portland`. When you open the social feed, you see posts from your neighborhood first, then your city, then your region. It's like a local newspaper that writes itself.

A local event or city feed might look like: `events@geo:us/or/portland`. Anyone in the Portland trust network can post to it. Popular content — posts that lots of people in the scope read — propagates outward automatically.

</details>

<details className="faq-item">
<summary>How do I find my friends?</summary>

By exchanging public keys — either in person (QR code scan) or through a mutual trusted contact. Once you have someone's key, you can always find them on the mesh. They can also register a human-readable name like `alice@geo:us/or/portland` through [MHR-Name](/docs/L5-services/mhr-name), and you can look them up by name.

</details>

<details className="faq-item">
<summary>How do I browse without a search engine?</summary>

Three ways:

1. **Trust-based feeds**: You see content from people your community trusts. This is the default experience — open the app and see what your neighborhood is reading.
2. **Curated channels**: People you trust create curated feeds — hand-picked collections of the best content on a topic. Subscribe to feeds that match your interests.
3. **Name resolution**: If you know what you're looking for, type its name. [MHR-Name](/docs/L5-services/mhr-name) resolves human-readable names to content — like DNS, but without central authority.

</details>

---

## Creating Content

<details className="faq-item">
<summary>Does it cost money to post?</summary>

Yes — a tiny amount. Every post is stored on the network, and storage costs MHR. This is the anti-spam mechanism: posting costs tokens, so flooding the network with garbage is economically irrational.

Within your trust network (friends and neighbors), posting is free.

</details>

<details className="faq-item">
<summary>Can I earn from my content?</summary>

Yes. When someone pays to read your full post, a portion of their fee goes back to you — this is called **kickback**. You set the percentage when you publish (default is about 50%).

Popular content that earns more kickback than it costs to store becomes **self-funding** — it lives as long as people read it, at no cost to you. Content nobody reads expires when you stop paying for storage.

</details>

<details className="faq-item">
<summary>What kinds of content can I publish?</summary>

Anything: text posts, photo essays, music albums, video courses, scientific papers, games, software, podcasts. The same envelope/post system works for all content types. The preview shows whatever makes sense (track listing for music, abstract for papers, screenshots for games).

</details>

<details className="faq-item">
<summary>What about curators?</summary>

Anyone can be a curator. You create a curated feed — a list of the best posts you've found — and publish it. Others subscribe to your feed. When they read posts you recommended, the original authors earn kickback AND you earn a separate fee for the curation. Two people get paid: the creator and the curator.

</details>

---

## Communication

<details className="faq-item">
<summary>How do I message someone?</summary>

Open the messaging app, pick a contact, type your message. It's end-to-end encrypted — only you and the recipient can read it. If they're offline, the network holds the message and delivers it when they come back online (like email, but encrypted).

</details>

<details className="faq-item">
<summary>Can I make voice calls?</summary>

Yes, on connections with enough bandwidth. WiFi and cellular links support real-time voice. On slow radio links, voice isn't practical — use text messaging instead.

</details>

<details className="faq-item">
<summary>Can I send photos and videos?</summary>

Yes. The app adapts to your connection:

| Connection | What you can send/receive |
|-----------|--------------------------|
| WiFi or cellular | Photos, videos, full media |
| Moderate radio link | Compressed images, text |
| Slow radio (LoRa) | Text only, with tiny image previews |

You never need to think about this — the app handles it automatically.

</details>

<details className="faq-item">
<summary>What happens when I'm moving around?</summary>

Your device automatically handles roaming. It constantly listens for nearby nodes on all its radios (WiFi, Bluetooth, LoRa) and connects to the best one available — no manual switching required.

- **Walk into a cafe with a Mehr WiFi node?** Your device connects in under a second.
- **Walk out of WiFi range?** Traffic shifts to LoRa automatically. Apps adapt (images become text previews).
- **On a voice call while moving?** The call hands off between nodes with less than a second of interruption. Quality may change but the call doesn't drop.

</details>

---

## Community

<details className="faq-item">
<summary>How do communities form?</summary>

You mark people as trusted. They mark you as trusted. When a group of people all trust each other, that's a community — a [trust neighborhood](/docs/L3-economics/trust-neighborhoods). Nobody "creates" it or "runs" it — it emerges from real-world relationships.

Each person tags themselves with where they are (e.g., Portland, Oregon) and what they're into (e.g., gaming, science). These tags — called [scopes](/docs/L3-economics/trust-neighborhoods#hierarchical-scopes) — are how feeds and names work. No authority approves your tags. Communities converge on naming through social consensus, the same way they do today.

</details>

<details className="faq-item">
<summary>Can I run a local forum?</summary>

Yes. A forum is just a shared space where community members post. A moderator contract enforces whatever rules your community agrees on. Different forums can have different rules — there's no platform-wide content policy.

</details>

<details className="faq-item">
<summary>Can I sell things on a local marketplace?</summary>

Yes. Post a listing (text, photos, price) tagged with your geographic scope, and it's visible to your neighborhood. Buyers contact you directly. Payment can happen in person, through an external service, or through MHR escrow.

</details>

<details className="faq-item">
<summary>Can I host a website or blog?</summary>

Yes, and it's much simpler than traditional hosting:

| Traditional web | Mehr |
|----------------|-------|
| Rent a server | Not needed — content lives in the mesh |
| Buy a domain name ($10–50/year) | Pick a name for free (`myblog@geo:us/or/portland`) |
| Get an SSL certificate | Not needed — everything is encrypted and verified automatically |
| Pay for traffic spikes | Visitors pay their own relay costs, not you |

You pay only for storage (tiny amounts of MHR), and popular content gets cheaper because it's cached everywhere.

</details>

<details className="faq-item">
<summary>Can I store my files on the network?</summary>

Yes. Mehr provides [decentralized cloud storage](/docs/L6-applications/cloud-storage) — like Dropbox, but your files are encrypted on your device before being stored across multiple mesh nodes. No cloud provider has access to your files. Your devices sync automatically through the mesh. You can share files with specific people by granting them a decryption key.

If you don't want to deal with tokens, a [gateway operator](/docs/L3-economics/token-economics#gateway-operators-fiat-onramp) can offer cloud storage as a fiat-billed service — same experience as any cloud storage app, but backed by the mesh.

</details>

<details className="faq-item">
<summary>Can I earn by sharing my storage?</summary>

Yes — and it's one of the easiest ways to start earning MHR. Any device with spare disk space can offer [storage services](/docs/L6-applications/cloud-storage#earning-mhr-through-storage). You configure how much space to share, storage nodes advertise their availability, and clients form agreements with you. You earn μMHR for every epoch your storage is used. No special hardware needed — a Raspberry Pi with a USB drive works fine.

</details>

<details className="faq-item">
<summary>What happens when I move to a different location?</summary>

Your device [roams seamlessly](/docs/L6-applications/roaming). Mehr identity is your cryptographic key, not a network address. When you walk from WiFi to LoRa range to another WiFi node, your connections don't drop — traffic shifts to the best available transport in under a second. Apps adapt to link quality (images become previews on slow links, full quality returns on fast links). You can even plug an ethernet cable into different ports at different locations and stay connected with zero configuration.

</details>

---

## Privacy and Safety

<details className="faq-item">
<summary>Is it private?</summary>

Yes. Messages are end-to-end encrypted. Social posts can be public (scoped) or neighborhood-only (unscoped). There is no central server with a copy of your messages, your contacts, or your browsing history. Your identity is a cryptographic key — you never need to provide your real name.

</details>

<details className="faq-item">
<summary>Can someone spy on my messages?</summary>

No. End-to-end encryption means only the sender and recipient can read a message. Relay nodes carry encrypted blobs they cannot decrypt. Even your direct neighbors don't know if a packet originated from you or if you're just relaying it for someone else.

</details>

<details className="faq-item">
<summary>Can someone shut down the network?</summary>

No single point of failure. There's no server to seize, no company to shut down, no domain to block. As long as any two devices can reach each other — by radio, WiFi, Bluetooth, or anything else — the network works.

</details>

<details className="faq-item">
<summary>What about illegal or harmful content?</summary>

There is no central moderator. Instead, [content governance](/docs/L3-economics/content-governance) is distributed:

- **Every node decides for itself** what to store, relay, and display. No node is forced to host or forward content it objects to.
- **Trust revocation** is the enforcement mechanism. If your community discovers you're producing harmful content, they remove you from trusted peers — cutting off your free relay, storage, credit, and reputation.
- **Economics limits abuse**: posting costs money, content starts local (doesn't go global without genuine demand), and there's no algorithm to amplify engagement.
- **Curators filter quality**: most readers follow curated feeds, not raw unfiltered streams.

This is the same tradeoff every free society makes: individual freedom with social consequences. No central authority decides what's allowed, but communities enforce their own norms.

</details>

---

## Economy

<details className="faq-item">
<summary>How does money work on Mehr?</summary>

MHR is the network's internal token. Think of it like arcade tokens — valuable inside the arcade (network services), designed to be spent.

- **You earn MHR** by relaying traffic, storing data, or providing other services
- **You spend MHR** when your messages cross through untrusted infrastructure, or when you read paid content
- **Content creators earn MHR** through kickback — a share of what readers pay
- **Talking to friends is always free** — MHR only matters at trust boundaries

</details>

<details className="faq-item">
<summary>What's it worth in real money?</summary>

MHR has no official exchange rate with any fiat currency. But because it buys real services (bandwidth, storage, compute, content), it has real value — and people will likely trade it informally. This is fine. The network's health doesn't depend on preventing exchange; it works as a closed-loop economy regardless.

</details>

<details className="faq-item">
<summary>Can I buy MHR instead of earning it?</summary>

Yes. If someone sells you MHR they earned through relay work, you can spend it on the network. The seller earned those tokens through real service — the network benefited. You're indirectly funding infrastructure. This is no different from buying bus tokens.

</details>

<details className="faq-item">
<summary>What if I don't want to run a relay? Can I just pay to use the network?</summary>

Yes. **Gateway operators** handle this. A gateway is a regular node that accepts fiat payment (subscription, prepaid, or pay-as-you-go) and gives you network access in return. From your perspective, you sign up, pay a monthly bill, and use the network — just like a phone plan. You never see or touch MHR tokens.

The gateway adds you as a trusted peer and extends credit, so your traffic flows through them for free. The gateway handles MHR costs on your behalf. Multiple gateways compete in any area, so pricing stays competitive. You can switch gateways at any time — your identity is yours, not the gateway's.

See [Gateway Operators](/docs/L3-economics/token-economics#gateway-operators-fiat-onramp) for details.

</details>

<details className="faq-item">
<summary>Can I get rich from MHR?</summary>

That's not the point. MHR is designed to be spent on services, not hoarded. There's no ICO and no hidden allocation — the genesis gateway receives a transparent, disclosed allocation visible in the ledger from day one. Tail emission (0.1% annual) mildly dilutes idle holdings. Lost keys permanently remove supply. The economic incentive is to earn and spend, not to accumulate.

</details>

---

## Licensing and Digital Assets

<details className="faq-item">
<summary>Can I sell licenses for my work on Mehr?</summary>

Yes. Mehr has a built-in [digital licensing](/docs/L6-applications/licensing) system. You publish a **LicenseOffer** alongside your asset (photo, music, software, dataset) specifying terms — price, whether derivatives are allowed, whether commercial use is permitted, and how many licenses can be issued. Buyers pay you directly (in MHR or fiat) and receive a **LicenseGrant** signed by both parties.

</details>

<details className="faq-item">
<summary>How does license verification work?</summary>

A LicenseGrant is cryptographically signed by both the licensor and licensee. Anyone can verify it by checking the Ed25519 signatures — no network connection needed. When someone uses a licensed asset in a derivative work, they include the LicenseGrant hash in their post's references. Readers can follow the chain: derivative work → LicenseGrant → LicenseOffer → original asset.

</details>

<details className="faq-item">
<summary>Can licenses be enforced?</summary>

Not at the protocol level. Mehr proves a license exists (or doesn't) — it doesn't prevent unlicensed use. This is the same as the real world: copyright exists whether or not someone violates it. Enforcement happens through social reputation (community trust) and legal systems (courts). The cryptographic proof makes disputes straightforward to resolve.

</details>

<details className="faq-item">
<summary>Do licenses work outside of Mehr?</summary>

Yes. A LicenseGrant contains public keys and signatures that can be verified with standard cryptographic tools — no Mehr software needed. A website, archive, or court can verify license authenticity from the grant alone. The rights described in the license apply wherever the parties intend them to, not just on the Mehr network.

</details>

---

## Compared to What I Use Now

<details className="faq-item">
<summary>How is this different from the regular internet?</summary>

| | Regular Internet | Mehr |
|--|----------------|-------|
| **Works without ISP** | No | Yes — radio, WiFi, anything |
| **Works during internet shutdown** | No | Yes — local mesh continues |
| **Free local communication** | No — you pay your ISP | Yes — trusted peers are free |
| **Your data on a corporate server** | Yes (Google, Meta, etc.) | No — data stays on your devices and your community's mesh |
| **Can be censored** | Yes — ISPs, DNS, app stores | Extremely difficult — no central control point |
| **Needs an account** | Email, phone number, ID | Just a cryptographic key (anonymous) |
| **Content creators earn** | Platform takes most/all revenue | Direct kickback to creator (~50%) |

</details>

<details className="faq-item">
<summary>Can Mehr replace my internet connection?</summary>

**It depends on where you live.**

In a **dense area** (apartment building, neighborhood, campus) where many nodes run WiFi, the mesh delivers 10–300 Mbps per hop — comparable to cable internet. Add a few shared internet uplinks (Starlink, fiber, cellular) and the community mesh handles distribution. Most people would save 50–75% on connectivity costs.

In a **rural or remote area** with only LoRa radio coverage, Mehr delivers 0.3–50 kbps — enough for text messaging, basic social feeds, and push-to-talk voice, but not video streaming. Here, Mehr provides communication where there was none, or shares one expensive satellite connection across an entire village.

| Your situation | What Mehr does |
|---------------|-----------------|
| Dense urban, many WiFi nodes | Replaces individual ISP subscriptions — share uplinks, save money |
| Suburban, mixed WiFi + LoRa | Supplements your connection — free local communication, shared backup uplink |
| Rural, LoRa only | Provides communication where there is none — text, voice, local services |
| No infrastructure at all | Only option that works — $30 solar radio nodes, no towers needed |

</details>

<details className="faq-item">
<summary>How is this different from Signal or WhatsApp?</summary>

Signal and WhatsApp need internet access and rely on central servers for delivery. Mehr works without internet, stores messages across the mesh (not one company's servers), and the network itself is decentralized. Nobody can block your access because there's nothing to block.

</details>

<details className="faq-item">
<summary>How is this different from Bitcoin?</summary>

Bitcoin is money designed for global financial transactions. MHR is an internal utility token for paying network services. They share some concepts (cryptographic keys, no central authority) but serve completely different purposes. MHR is more like "bus tokens for the network" than a cryptocurrency.

</details>

<details className="faq-item">
<summary>How is this different from Mastodon/Bluesky?</summary>

Mastodon and Bluesky are decentralized social networks that still require internet access and depend on servers run by someone. On Mehr:

| | Mastodon/Bluesky | Mehr |
|---|---|---|
| **Requires internet** | Yes | No — works on radio alone |
| **Requires servers** | Yes (someone hosts instances) | No — content lives on mesh nodes |
| **Content moderation** | Server admin decides | Each node decides for itself |
| **Posting cost** | Free | Small fee (anti-spam) |
| **Creator revenue** | None built-in | Kickback on every read |
| **Works offline** | No | Yes — local mesh continues |

</details>

---

## How It Works (Simple Version)
<!-- Source: docs/eli5.md -->

# How Mehr Works (Simple Version)

No jargon. No technical details. Just how it works.

## The Problem

When you send a message to your neighbor across the street, it travels like this:

```mermaid
graph LR
    You -->|WiFi| Router1[Router] -->|ISP| ISP1[ISP] -->|route| DC[Data center\nmaybe another country] -->|route| ISP2[ISP] -->|ISP| Router2[Router] -->|WiFi| Neighbor
```

Your message travels hundreds of miles to reach someone 50 feet away. You pay a phone company for this. If the company shuts off your service — or a government tells them to — you can't communicate at all.

## The Solution

Mehr lets devices talk directly:

```mermaid
graph LR
    You -->|radio / WiFi| Neighbor
```

No phone company. No data center. No monthly bill. Just devices talking.

## How It Gets Bigger

One house talking to another is nice, but not very useful by itself. Mehr gets useful when many devices form a chain:

```mermaid
graph LR
    You -->|radio| Neighbor -->|WiFi| Cafe -->|internet| World[The World]
```

Each device passes messages along, like a bucket brigade. Your message hops from device to device until it reaches its destination. This chain of devices is called a **mesh**.

```mermaid
graph LR
    You --> Neighbor
    Neighbor --> School --> Library --> More[...]
    Neighbor --> Cafe --> Gateway --> Internet
```

Messages find the best path automatically. If the cafe goes offline, traffic routes through the school instead. No single point of failure.

## Three Rules

**Rule 1: Friends help for free.**

You mark people as "trusted" — like adding a contact. Your devices help each other automatically, at no cost. A neighborhood where everyone trusts each other communicates completely free.

```mermaid
graph LR
    You <-->|trust| Neighbor <-->|trust| Friend
```

> Messages between these three: always free. No tokens. No payments. No overhead.

**Rule 2: Strangers pay a tiny fee.**

If your message passes through a stranger's device, you pay a tiny fee. This is fair — they're using their electricity and bandwidth to help you.

```mermaid
graph LR
    You -->|"trust (free)"| Neighbor -->|"pay (tiny fee)"| Stranger -->|"pay (tiny fee)"| Destination
```

**Rule 3: Helping earns you credit.**

Every time your device passes along someone else's message, you earn credit. This credit is called **MHR**. You spend MHR when you use the network. You earn MHR when others use yours.

```mermaid
graph LR
    Help[You help others] --> Earn[Earn MHR] --> Spend[Spend MHR] --> Others[Others help you] --> Help
```

## What You Can Do

| What | How | Cost |
|------|-----|------|
| Message a friend | Like texting, but encrypted | Free |
| Message a stranger | Same, routed through the mesh | Tiny fee |
| Browse social feeds | See headlines and previews | Free |
| Read full posts | Tap to open content you want | Small fee to author |
| Post content | Text, photos, music, anything | You pay to publish |
| Host a website | Your device serves it | Visitors pay their own way |
| Make a voice call | Works well on WiFi | Same as messaging |
| Store files | Other devices keep copies | Small ongoing fee |

## Social Media on Mehr

Every post has two layers:

```mermaid
graph TD
    Preview["FREE PREVIEW\nHeadlines, summaries, thumbnails\nBrowse as much as you want — zero cost"] -->|tap to open| Full["FULL CONTENT\nArticle, image, song, or video\nTiny fee goes to the author"]
```

**Popular posts pay for themselves.** If enough people read a post, the author earns more than it cost to publish. Posts nobody reads expire naturally — no moderator needed.

**No algorithm decides what you see.** You follow people. You subscribe to topics ("gaming", "local news"). You follow curators — real humans who pick the best stuff. Your feed is what you chose, in chronological order.

## The Money Part

MHR is like tokens at an arcade. You earn them by helping (relaying messages, storing data) and spend them by using (reaching distant people, reading content).

**Can I buy MHR with real money?** The network doesn't have a store, but people may sell tokens to each other. This is fine — someone earned those tokens through real work.

**Can I get rich from MHR?** That's not the point. MHR is designed to be spent, not saved. It's bus tokens, not stocks.

**What if I have no tokens?** You can still talk to your friends for free. MHR only matters when your messages cross through strangers' devices.

## What If I Don't Have Internet?

That's the whole point. Mehr works with:

| Connection | Speed | What you can do |
|-----------|-------|----------------|
| Radio (LoRa) | Slow but long range (up to 15 km) | Text messages, headlines, basic feeds |
| WiFi | Fast, short range | Everything — photos, video, calls |
| Cellular | Fast, wide range | Everything |
| Satellite | Fast, expensive | Gateway for an entire community |
| Anything else | Varies | If it moves bytes, Mehr uses it |

A village with no internet can communicate over radio. Add one satellite dish and the whole village gets internet access through the mesh — shared, at a fraction of the individual cost.

**Traditional model** (everyone pays separately — total: $1,500/month):

```mermaid
graph LR
    H1[House 1] -->|$30/month| ISP1[ISP]
    H2[House 2] -->|$30/month| ISP2[ISP]
    H3[House 3] -->|$30/month| ISP3[ISP]
    H50[House 50] -->|$30/month| ISP50[ISP]
```

**Mehr model** (shared through the mesh — total: ~$30/month + tiny MHR fees):

```mermaid
graph LR
    H1[House 1] -->|radio| H12[House 12] -->|WiFi| GW[Gateway] -->|"$30/month"| Internet
    H2[House 2] -->|radio| H12
    H3[House 3] -->|WiFi| GW
```

> Gateway operator earns from the neighborhood. Everyone else saves 75%+.

## Who Controls It?

Nobody. There is no company behind Mehr. No server to shut down. No account to ban. No terms of service to accept.

- **Your identity** is a cryptographic key on your device. No email, no phone number, no real name required.
- **Your data** lives on your device and your community's devices — not on a corporate server.
- **Your feed** is what you chose to follow — not what an algorithm chose for you.
- **Your content** stays up as long as you (or your readers) pay for it — no platform can remove it.

## The Big Picture

**Traditional internet:**

```mermaid
graph LR
    Everyone1[Everyone] -->|pays| BigCo[Big companies\ncontrol everything] -->|provide| Service
```

**Mehr:**

```mermaid
graph LR
    E1[Everyone] <-->|helps| E2[Everyone]
```

## Want to Learn More?

- [FAQ](faq) — answers to common questions in plain language
- [Introduction](introduction) — the full technical overview
- [MHR Token](/docs/L3-economics/mhr-token) — how the economy works in detail
- [Social](/docs/L6-applications/social) — how social media works on Mehr
- [Real-World Economics](/docs/L3-economics/real-world-impact) — actual cost savings and earnings

---

## Full Specification
<!-- Source: docs/specification.md -->




# Mehr Protocol Specification v1.0

This page is the normative reference for the Mehr protocol. Individual documentation pages provide detailed explanations; this page summarizes the protocol constants, wire formats, and layer dependencies in one place.

## Status

| | |
|---|---|
| **Version** | 1.0 |
| **Status** | Design complete, pre-implementation |
| **Normative sections** | Layers 0–5 (transport through services) |
| **Informative sections** | Layer 6 (applications), hardware reference, roadmap |

## Protocol Constants

| Constant | Value | Defined In |
|----------|-------|-----------|
| Gossip interval | 60 seconds | [Network Protocol](/docs/L1-network/network-protocol#gossip-protocol) |
| Protocol overhead budget | ≤10% of link bandwidth | [Bandwidth Budget](/docs/L1-network/network-protocol#bandwidth-budget) |
| CompactPathCost size | 7 bytes (constant) | [Network Protocol](/docs/L1-network/network-protocol#mehr-extension-compact-path-cost) |
| MehrExtension magic byte | `0x4E` ('N') | [Network Protocol](/docs/L1-network/network-protocol#mehr-extension-compact-path-cost) |
| Destination hash size | 16 bytes (128-bit) | [Network Protocol](/docs/L1-network/network-protocol#identity-and-addressing) |
| Smallest MHR unit | 1 μMHR | [MHR Token](/docs/L3-economics/mhr-token#properties) |
| Supply ceiling | 2^64 μMHR (asymptotic) | [MHR Token](/docs/L3-economics/mhr-token#supply-model) |
| Default relay lottery probability | 1/100 | [Stochastic Rewards](/docs/L3-economics/payment-channels#example) |
| Payment channel state size | 200 bytes | [Payment Channels](/docs/L3-economics/payment-channels#channel-state) |
| Dispute challenge window | 2,880 gossip rounds (~48h) | [Payment Channels](/docs/L3-economics/payment-channels#channel-lifecycle) |
| Channel abandonment threshold | 4 epochs | [Payment Channels](/docs/L3-economics/payment-channels#channel-lifecycle) |
| Epoch trigger: settlement count | ≥10,000 batches | [CRDT Ledger](/docs/L3-economics/epoch-compaction#epoch-triggers) |
| Epoch trigger: GSet memory | ≥500 KB | [CRDT Ledger](/docs/L3-economics/epoch-compaction#epoch-triggers) |
| Epoch acknowledgment threshold | 67% of active set | [CRDT Ledger](/docs/L3-economics/epoch-compaction#epoch-lifecycle) |
| Epoch verification window | 4 epochs after activation | [CRDT Ledger](/docs/L3-economics/epoch-compaction#epoch-lifecycle) |
| Bloom filter FPR (epoch) | 0.01% | [CRDT Ledger](/docs/L3-economics/epoch-compaction#bloom-filter-sizing) |
| DHT replication factor | k=3 | [MHR-DHT](/docs/L5-services/mhr-dht#replication-factor) |
| DHT XOR weight (w_xor) | 0.7 | [MHR-DHT](/docs/L5-services/mhr-dht#lookup-scoring-function) |
| Storage chunk size | 4 KB | [MHR-Store](/docs/L5-services/mhr-store#chunking) |
| Presence beacon size | 20 bytes | [Discovery](/docs/L4-marketplace/discovery#presence-beacons) |
| Presence beacon interval | 10 seconds | [Discovery](/docs/L4-marketplace/discovery#presence-beacons) |
| Transitive credit limit | 10% per hop, max 2 hops | [Trust & Neighborhoods](/docs/L3-economics/trust-neighborhoods#trust-based-credit) |
| Constrained transport class MTU | 484 bytes | [Physical Transport](/docs/L0-physical/physical-transport#transport-classes-and-variable-packet-sizes) |
| Standard transport class MTU | 1,500 bytes | [Physical Transport](/docs/L0-physical/physical-transport#transport-classes-and-variable-packet-sizes) |
| Bulk transport class MTU | 4,096 bytes | [Physical Transport](/docs/L0-physical/physical-transport#transport-classes-and-variable-packet-sizes) |
| Route probe rate limit | 1 probe/minute per destination | [Network Protocol](/docs/L1-network/network-protocol#route-probing) |
| Route probe min link bandwidth | 10 kbps | [Network Protocol](/docs/L1-network/network-protocol#route-probing) |
| ReservationRequest size | 43 bytes | [Network Protocol](/docs/L1-network/network-protocol#bandwidth-reservation) |
| ReservationCommitment size | 23 bytes | [Network Protocol](/docs/L1-network/network-protocol#bandwidth-reservation) |
| ReservationRelease size | 11 bytes | [Network Protocol](/docs/L1-network/network-protocol#bandwidth-reservation) |
| Reservation escrow floor | 10% of estimated total | [Payment Channels](/docs/L3-economics/payment-channels#reservation-payment-progressive-escrow) |
| Reservation chunk size | 1 MB | [Payment Channels](/docs/L3-economics/payment-channels#reservation-payment-progressive-escrow) |
| Reservation inactivity timeout | 60 seconds | [Network Protocol](/docs/L1-network/network-protocol#bandwidth-reservation) |
| Reservation underperformance threshold | &lt;50% committed_bps for 3 chunks | [Network Protocol](/docs/L1-network/network-protocol#bandwidth-reservation) |
| Reservation reroute: cost improvement | ≥25% reduction | [Network Protocol](/docs/L1-network/network-protocol#bandwidth-reservation) |
| Reservation reroute: bandwidth improvement | ≥50% increase | [Network Protocol](/docs/L1-network/network-protocol#bandwidth-reservation) |
| PacketTooBig signal size | 18 bytes | [Physical Transport](/docs/L0-physical/physical-transport#path-mtu-behavior) |
| Max scopes per node | 8 | [Trust & Neighborhoods](/docs/L3-economics/trust-neighborhoods#hierarchical-scopes) |
| Max scope depth | 8 segments | [Trust & Neighborhoods](/docs/L3-economics/trust-neighborhoods#wire-format) |
| Max scope segment length | 32 characters | [Trust & Neighborhoods](/docs/L3-economics/trust-neighborhoods#wire-format) |
| Vouch expiry (default) | 30 epochs | [MHR-ID](/docs/L5-services/mhr-id#vouch-properties) |
| Kickback rate range | 0–255 (u8) | [MHR-Store](/docs/L5-services/mhr-store#kickback-rate) |
| Default kickback rate | 128 (~50%) | [Content Propagation](/docs/L3-economics/propagation#protocol-constants) |
| IdentityClaim min size | 126 bytes | [MHR-ID](/docs/L5-services/mhr-id#wire-format) |
| Vouch size | 121 bytes | [MHR-ID](/docs/L5-services/mhr-id#vouch-wire-format) |
| Claim type: GeoPresence | 0 | [MHR-ID](/docs/L5-services/mhr-id#claim-types) |
| Claim type: CommunityMember | 1 | [MHR-ID](/docs/L5-services/mhr-id#claim-types) |
| Claim type: KeyRotation | 2 | [MHR-ID](/docs/L5-services/mhr-id#claim-types) |
| Claim type: Capability | 3 | [MHR-ID](/docs/L5-services/mhr-id#claim-types) |
| Claim type: ExternalIdentity | 4 | [MHR-ID](/docs/L5-services/mhr-id#claim-types) |
| Claim type: ProfileField | 5 | [MHR-ID](/docs/L5-services/mhr-id#profile-fields) |
| Visibility: Public | 0 | [MHR-ID](/docs/L5-services/mhr-id#visibility-controls) |
| Visibility: TrustNetwork | 1 | [MHR-ID](/docs/L5-services/mhr-id#visibility-controls) |
| Visibility: DirectTrust | 2 | [MHR-ID](/docs/L5-services/mhr-id#visibility-controls) |
| Visibility: Named | 3 | [MHR-ID](/docs/L5-services/mhr-id#visibility-controls) |
| ProfileField value type: Text | 0 | [MHR-ID](/docs/L5-services/mhr-id#value-types) |
| ProfileField value type: ContentHash | 1 | [MHR-ID](/docs/L5-services/mhr-id#value-types) |
| ProfileField value type: Coordinates | 2 | [MHR-ID](/docs/L5-services/mhr-id#value-types) |
| ProfileField value type: Integer | 3 | [MHR-ID](/docs/L5-services/mhr-id#value-types) |
| Identity challenge method: Crawler | 0 | [MHR-ID](/docs/L5-services/mhr-id-verification#identity-linking) |
| Identity challenge method: OAuth | 1 | [MHR-ID](/docs/L5-services/mhr-id-verification#identity-linking) |
| Max name length | 64 bytes | [MHR-Name](/docs/L5-services/mhr-name#name-format) |
| Name binding min size | 122 bytes | [MHR-Name](/docs/L5-services/mhr-name#namebinding) |
| Name expiry | 30 epochs | [MHR-Name](/docs/L5-services/mhr-name#name-registration) |
| Name target type: NodeID | `0x01` | [MHR-Name](/docs/L5-services/mhr-name#wire-format) |
| Name target type: ContentHash | `0x02` | [MHR-Name](/docs/L5-services/mhr-name#wire-format) |
| Name target type: AppManifest | `0x03` | [MHR-Name](/docs/L5-services/mhr-name#wire-format) |
| Name context sub-type: Register | `0x08` | [MHR-Name](/docs/L5-services/mhr-name#message-types) |
| Name context sub-type: Lookup | `0x09` | [MHR-Name](/docs/L5-services/mhr-name#message-types) |
| Name context sub-type: LookupResponse | `0x0A` | [MHR-Name](/docs/L5-services/mhr-name#message-types) |
| AppManifest format version | 1 | [MHR-App](/docs/L5-services/mhr-app#manifest-wire-format) |
| Max contracts per manifest | 15 | [MHR-App](/docs/L5-services/mhr-app#appmanifest) |
| Max app dependencies per manifest | 8 | [MHR-App](/docs/L5-services/mhr-app#dependencies) |
| Max pub topic templates per manifest | 4 | [MHR-App](/docs/L5-services/mhr-app#appmanifest) |
| Max app display name | 32 bytes | [MHR-App](/docs/L5-services/mhr-app#appmanifest) |
| App type: Full | 0 | [MHR-App](/docs/L5-services/mhr-app#app-types) |
| App type: Headless | 1 | [MHR-App](/docs/L5-services/mhr-app#app-types) |
| App type: Static | 2 | [MHR-App](/docs/L5-services/mhr-app#app-types) |
| App context sub-type: ManifestPublish | `0x0B` | [MHR-App](/docs/L5-services/mhr-app#manifest-message-types) |
| App context sub-type: ManifestLookup | `0x0C` | [MHR-App](/docs/L5-services/mhr-app#manifest-message-types) |
| App context sub-type: ManifestLookupResponse | `0x0D` | [MHR-App](/docs/L5-services/mhr-app#manifest-message-types) |
| Geo verification: min vouches | 3 (for Verified level) | [Voting](/docs/L6-applications/voting#geoverificationlevel) |
| Protocol version encoding | 1 byte (major 4 bits, minor 4 bits) | [Versioning](/docs/L1-network/versioning#version-field) |
| Extended version escape | Major = 15 → read u16 pair from TLV | [Versioning](/docs/L1-network/versioning#version-field) |
| Current protocol version | `0x10` (v1.0) | [Versioning](/docs/L1-network/versioning#version-field) |
| Emission halving shift clamp | max 63 (prevents UB at epoch 6.4M+) | [MHR Token](/docs/L3-economics/mhr-token#supply-model) |
| Max curated feed entries | 256 per page | [Social](/docs/L6-applications/social#5-curated-feed) |
| LicenseOffer min size | ~160 bytes | [Digital Licensing](/docs/L6-applications/licensing#wire-format) |
| LicenseGrant size | 226 bytes | [Digital Licensing](/docs/L6-applications/licensing#wire-format) |
| Max custom license terms | 1024 characters | [Digital Licensing](/docs/L6-applications/licensing#licenseoffer) |

## Cryptographic Primitives

| Purpose | Algorithm | Output / Key Size |
|---------|-----------|-------------------|
| Identity / Signing | Ed25519 | 256-bit (32-byte public key) |
| Key Exchange | X25519 (Curve25519 DH) | 256-bit |
| Identity Hashing | Blake2b | 256-bit → 128-bit truncated |
| Content Hashing | Blake3 | 256-bit |
| Symmetric Encryption | ChaCha20-Poly1305 | 256-bit key, 96-bit nonce |
| Relay Lottery (VRF) | ECVRF-ED25519-SHA512-TAI (RFC 9381) | 80-byte proof |
| Erasure Coding | Reed-Solomon | Configurable k,m |

## Layer Dependency Graph

```mermaid
graph TD
    L6["Layer 6: Applications<br/>Messaging, Social, Voice, Voting, Licensing, Cloud Storage, Roaming, Hosting"] --> L5
    L5["Layer 5: Service Primitives<br/>MHR-Store, MHR-DHT, MHR-Pub, MHR-Compute, MHR-Name, MHR-ID, MHR-App"] --> L4
    L4["Layer 4: Capability Marketplace<br/>Discovery, Agreements, Verification"] --> L3
    L3["Layer 3: Economic Protocol<br/>MHR Token, Token Economics, Token Security, Stochastic Rewards, CRDT Ledger, Epoch Compaction, Trust Neighborhoods, Propagation"] --> L2
    L2["Layer 2: Security<br/>Link encryption, E2E encryption, Authentication, Key management"] --> L1
    L1["Layer 1: Network Protocol<br/>Identity, Addressing, Routing, Gossip, Congestion Control"] --> L0
    L0["Layer 0: Physical Transport<br/>LoRa, WiFi, Cellular, LTE-M, NB-IoT, Ethernet, BLE, Fiber, Serial"]
```

Each layer depends **only** on the layer directly below it. Applications never touch transport details. Payment never touches routing internals.

## Serialization Rules

All Mehr wire formats use the following conventions:

| Rule | Value |
|------|-------|
| **Byte order** | Little-endian for all multi-byte integers (u16, u32, u64, i64) |
| **Encoding** | Fixed-size binary fields; no self-describing framing (not CBOR, not JSON) |
| **TLV extensions** | Type (u8), Length (u8, max 255), Data (variable). Used in MehrExtension only |
| **Strings** | UTF-8, length-prefixed with u16 (community labels, function IDs) |
| **Hashes** | Raw bytes, no hex encoding on the wire |
| **Signatures** | Raw 64-byte Ed25519 signatures, no ASN.1/DER wrapping |
| **Normalized scores** | Computed on **decoded** values, then divided by the max decoded value in the candidate set. Result is IEEE 754 f32 on nodes that support FP; 16-bit fixed-point (Q0.16, value × 65535) on constrained nodes. Both yield equivalent routing decisions within rounding tolerance |

## Wire Format Summary

### Packet Format

```
[HEADER 2B] [DEST_HASH 16B] [CONTEXT 1B] [DATA 0-N bytes]
Constrained transport class: max 484 bytes (DATA 0-465B)
Standard transport class:    max 1,500 bytes (DATA 0-1,481B)
Bulk transport class:        max 4,096 bytes (DATA 0-4,077B)
Path max packet size: min(transport class MTU) across all hops
Source address: NOT PRESENT (structural sender anonymity)
```

### Mehr Announce Extension

```
[MAGIC 1B: 0x4E] [VERSION 1B] [CompactPathCost 7B] [TLV extensions...]
Minimum: 9 bytes. Carried in announce DATA field.
```

### CompactPathCost

```
[cumulative_cost 2B] [worst_latency_ms 2B] [bottleneck_bps 1B] [hop_count 1B] [bottleneck_mtu 1B]
Total: 7 bytes (constant regardless of path length)
```

### Payment Channel State

```
[channel_id 16B] [party_a 16B] [party_b 16B] [balance_a 8B]
[balance_b 8B] [sequence 8B] [sig_a 64B] [sig_b 64B]
Total: 200 bytes
```

## Specification Sections

| Spec Section | Documentation Page |
|-------------|-------------------|
| 0. Design Philosophy | [Introduction](introduction) |
| 1. Layer 0: Physical Transport | [Physical Transport](/docs/L0-physical/physical-transport) |
| 2. Layer 1: Network Protocol | [Network Protocol](/docs/L1-network/network-protocol) |
| 3. Layer 2: Security | [Security](/docs/L2-security/security) |
| 4. Layer 3: Economic Protocol | [MHR Token](/docs/L3-economics/mhr-token), [Token Economics](/docs/L3-economics/token-economics), [Token Security](/docs/L3-economics/token-security), [Stochastic Relay Rewards](/docs/L3-economics/payment-channels), [CRDT Ledger](/docs/L3-economics/crdt-ledger), [Epoch Compaction](/docs/L3-economics/epoch-compaction), [Trust & Neighborhoods](/docs/L3-economics/trust-neighborhoods), [Content Propagation](/docs/L3-economics/propagation), [Content Governance](/docs/L3-economics/content-governance), [Real-World Economics](/docs/L3-economics/real-world-impact) |
| 5. Layer 4: Capability Marketplace | [Overview](/docs/L4-marketplace/overview), [Discovery](/docs/L4-marketplace/discovery), [Agreements](/docs/L4-marketplace/agreements), [Verification](/docs/L4-marketplace/verification) |
| 6. Layer 5: Service Primitives | [MHR-Store](/docs/L5-services/mhr-store), [MHR-DHT](/docs/L5-services/mhr-dht), [MHR-Pub](/docs/L5-services/mhr-pub), [MHR-Compute](/docs/L5-services/mhr-compute), [MHR-Name](/docs/L5-services/mhr-name), [MHR-ID](/docs/L5-services/mhr-id), [MHR-App](/docs/L5-services/mhr-app) |
| 7. Layer 6: Applications | [Messaging](/docs/L6-applications/messaging), [Social](/docs/L6-applications/social), [Voice](/docs/L6-applications/voice), [Community Apps](/docs/L6-applications/community-apps), [Voting](/docs/L6-applications/voting), [Digital Licensing](/docs/L6-applications/licensing), [Cloud Storage](/docs/L6-applications/cloud-storage), [Roaming](/docs/L6-applications/roaming), [Hosting](/docs/L6-applications/hosting) |
| 8. Hardware Reference | [Reference Designs](hardware/reference-designs), [Device Tiers](hardware/device-tiers) |
| 9. Implementation Roadmap | [Roadmap](development/roadmap) |
| 10. Design Decisions | [Design Decisions](development/design-decisions) |
| 11. Protocol Versioning | [Versioning](/docs/L1-network/versioning) |
| 12. Open Questions | [Open Questions](development/open-questions) |

## Version

| Version | Status |
|---------|--------|
| **v1.0** | **Current** |

---

*The foundation — transport-agnostic mesh networking, cryptographic identity, Kleinberg small-world routing, stochastic relay rewards, CRDT settlement, epoch compaction, emergent trust neighborhoods, and the capability marketplace — is the protocol. Everything above it — storage, compute, pub/sub, naming, and applications — are services built on that foundation.*

---

## Hardware

### Reference Designs
<!-- Source: docs/hardware/reference-designs.md -->

# Hardware Reference Designs

Mehr is designed to run on hardware ranging from $30 solar-powered relays to GPU workstations. Every device participates at whatever level its hardware allows.

## Device Tiers Overview

> **Specification**
Mehr defines five hardware tiers spanning $30 solar relays to GPU workstations. Each tier maps to a protocol participation level: Minimal nodes relay only (L1), while Gateway and above run the full L2 stack with marketplace, storage, and compute.

| Tier | Hardware | Cost | Power | Primary Role |
|------|----------|------|-------|-------------|
| **Minimal** | ESP32 + LoRa SX1276 | ~$30 | 0.5W (solar) | Relay only |
| **Community** | Pi Zero 2 W + LoRa HAT + WiFi | ~$100 | 3W | LoRa/WiFi bridge, basic compute |
| **Gateway** | Pi 4/5 + LoRa + cellular modem + SSD | ~$300 | 10W | Internet uplink, storage, compute |
| **Backbone** | Mini PC + directional WiFi + fiber | ~$500+ | 25W+ | High-bandwidth backbone |
| **Inference** | x86 + GPU + Ethernet | ~$500+ | 100W+ | Heavy compute, ML inference |

## Minimal Relay Node

**Target**: Lowest-cost, always-on mesh relay

```
Components:
  - ESP32-S3 microcontroller
  - LoRa SX1276/SX1262 radio module
  - Small solar panel (2W) + LiPo battery
  - Weatherproof enclosure

Capabilities:
  - Packet relay only
  - MHR-Byte interpreter (~50 KB)
  - No storage beyond routing tables
  - 24/7 operation on solar power

Software:
  - Mehr firmware (Rust, no_std)
  - Transport: LoRa only
  - Runs: routing, payment channels, gossip
  - Cannot run: WASM, storage, heavy compute
```

**Earns from**: Routing fees (1-5 μMHR per packet relayed)

**Range**: 2-15 km line-of-sight with LoRa

> **Key Insight**
A $30 solar-powered ESP32 relay earns MHR from routing fees at zero operating cost. The economics work because the node provides irreplaceable value — extending mesh range — that no centralized alternative can replicate from a data center.

## Community Bridge Node

**Target**: Bridge between LoRa mesh and local WiFi network

```
Components:
  - Raspberry Pi Zero 2 W
  - LoRa HAT (SX1262)
  - Built-in WiFi
  - SD card (32 GB)
  - USB power supply (5V/2A)

Capabilities:
  - LoRa ↔ WiFi bridging
  - Basic MHR-Compute (MHR-Byte + light WASM)
  - Local storage (~16 GB usable)
  - MHR-DHT participation
  - Message caching for offline nodes

Software:
  - Mehr daemon (Rust, Linux)
  - Dual transport: LoRa + WiFi
  - Full protocol stack
```

**Earns from**: Bridging fees, compute delegation, storage

## Gateway Node

**Target**: Internet uplink for the mesh

```
Components:
  - Raspberry Pi 4/5 (4 GB+ RAM)
  - LoRa HAT
  - 4G/LTE cellular modem (or Ethernet)
  - SSD (256 GB+)
  - Powered supply (12V)

Capabilities:
  - Internet gateway (HTTP proxy, DNS relay)
  - Full MHR-Store storage node
  - MHR-DHT backbone participation
  - Full WASM compute
  - Epoch consensus participation

Software:
  - Full Mehr stack
  - Triple transport: LoRa + WiFi + Cellular/Ethernet
  - Gateway proxy services
```

**Earns from**: Internet gateway fees, storage fees, compute fees, routing

## Backbone Node

**Target**: High-bandwidth infrastructure linking mesh segments

```
Components:
  - Mini PC (Intel NUC or equivalent)
  - Directional WiFi antenna (point-to-point)
  - Fiber connection (where available)
  - SSD (1 TB+)
  - UPS/battery backup

Capabilities:
  - High-throughput routing (100+ Mbps)
  - Large-scale storage
  - Full compute services
  - Neighborhood discovery services
  - Epoch consensus coordination

Software:
  - Full Mehr stack, optimized for throughput
  - Transport: Directional WiFi + Fiber + Ethernet
```

**Earns from**: Bulk routing fees, backbone transit, storage

## Inference Node

**Target**: Heavy compute (ML inference, transcription, TTS)

```
Components:
  - x86 PC or server
  - GPU (NVIDIA RTX series or equivalent)
  - Ethernet connection
  - SSD (512 GB+)
  - Standard power supply

Capabilities:
  - ML model inference (Whisper, LLaMA, Stable Diffusion, etc.)
  - Speech-to-text, text-to-speech
  - Translation services
  - Any GPU-accelerated computation

Software:
  - Full Mehr stack
  - WASM runtime + native GPU compute
  - Model serving framework
  - Advertises offered_functions with pricing
```

**Earns from**: Compute fees for ML inference and heavy processing

---

### Device Capabilities by Tier
<!-- Source: docs/hardware/device-tiers.md -->

# Device Capabilities by Tier

Each hardware tier has different capabilities, which determine what the node can do on the network and how it earns MHR.

## Capability Matrix

> **Key Insight**
Every tier participates in gossip and payment channels — even the cheapest ESP32 relay. The protocol scales by restricting *what* each tier does (no WASM on Minimal, no ML on Gateway), not *whether* it participates in the economy.

| Capability | Minimal | Community | Gateway | Backbone | Inference |
|-----------|---------|-----------|---------|----------|-----------|
| Packet relay | Yes | Yes | Yes | Yes | Yes |
| LoRa transport | Yes | Yes | Yes | Optional | No |
| WiFi transport | No | Yes | Yes | Yes (directional) | Optional |
| Cellular transport | No | No | Yes | No | No |
| Ethernet/Fiber | No | No | Optional | Yes | Yes |
| MHR-Byte contracts | Yes | Yes | Yes | Yes | Yes |
| WASM contracts | No | Light | Full | Full | Full |
| MHR-Store storage | No | ~16 GB | ~256 GB | ~1 TB | ~512 GB |
| MHR-DHT participation | Minimal | Yes | Backbone | Backbone | Yes |
| Epoch consensus | No | No | Yes | Yes | Yes |
| Internet gateway | No | No | Yes | Optional | Optional |
| ML inference | No | No | No | No | Yes |
| Gossip participation | Full | Full | Full | Full | Full |
| Payment channels | Yes | Yes | Yes | Yes | Yes |

## Power and Deployment

| Tier | Power Draw | Power Source | Typical Deployment |
|------|-----------|-------------|-------------------|
| Minimal | 0.5W | Solar + LiPo | Outdoor, pole/tree-mounted |
| Community | 3W | USB wall adapter | Indoor, near window for LoRa |
| Gateway | 10W | 12V supply | Indoor, weatherproof enclosure |
| Backbone | 25W+ | Mains + UPS | Indoor, rack-mounted or desktop |
| Inference | 100W+ | Mains | Indoor, rack or desktop |

## Earning Potential

What each tier naturally earns from:

### Minimal (ESP32 + LoRa)
- Packet relay fees only
- Low per-packet revenue but high volume and zero operating cost (solar)
- Value: extends mesh range, maintains connectivity

### Community (Pi Zero + LoRa + WiFi)
- Bridging fees (LoRa ↔ WiFi translation)
- Basic compute delegation
- Small-scale storage
- Value: connects LoRa mesh to local WiFi network

### Gateway (Pi 4/5 + Cellular)
- Internet gateway fees (highest per-byte revenue)
- Storage fees
- Compute fees
- Epoch consensus participation
- Value: connects mesh to the wider internet

### Backbone (Mini PC + Directional WiFi)
- High-volume transit routing
- Large-scale storage
- Full compute services
- Value: high-bandwidth links between mesh segments

### Inference (GPU/NPU Workstation)
- ML inference fees (highest per-invocation revenue)
- Heavy compute services
- Includes: GPU workstations, servers with NPU/TPU, FPGA accelerators
- Value: provides advanced capabilities to the entire mesh

## Delegation Patterns

Since nodes delegate what they can't do locally, natural delegation chains form:

```
Minimal relay
  → delegates everything except routing to →
Community bridge
  → delegates bulk storage and internet to →
Gateway node
  → delegates heavy compute to →
Inference node (GPU/NPU)
```

Each delegation is a bilateral [capability agreement](/docs/L4-marketplace/agreements) with payment flowing through [channels](/docs/L3-economics/payment-channels).

> **Trade-off**
Delegation chains add latency and cost at each hop. A Minimal relay delegating compute to a Community node, which delegates storage to a Gateway, creates a 3-link economic dependency. If any link fails, the upstream node must re-discover and re-negotiate — trading simplicity for resilience.


---

## Interoperability

### Cross-Network Compatibility
<!-- Source: docs/interoperability/overview.md -->

# Cross-Network Compatibility

Mehr is not an island. A decentralized mesh protocol that can't talk to other networks is a walled garden with extra steps. This page explores how Mehr connects to existing protocols, which projects are worth bridging, and the architectural principles that make interoperability possible without compromising Mehr's core design.

## Design Principle: Bridges as Services, Not Primitives

Mehr deliberately avoids building interoperability into the protocol layer. Instead, bridges are **standalone gateway services** that advertise in the [capability marketplace](/docs/L4-marketplace/overview) like any other service — storage, compute, or relay.

This was an explicit [design decision](../development/design-decisions#protocol-bridges-standalone-gateway-services). The rationale:

> **Key Insight**
Bridges are marketplace services, not protocol primitives. Each bridge is discoverable, negotiable, verifiable, and payable through the same capability marketplace that handles storage and compute — no special protocol support required.

- **Protocol bridges need persistent connections** to external systems (Matrix federation, SSB replication, Nostr relays). MHR-Compute contracts are sandboxed with no network I/O — bridges don't fit the compute model.
- **Each external protocol evolves independently.** A protocol-level primitive would need to track Matrix spec changes, SSB protocol upgrades, and Nostr NIPs — an endless maintenance burden on the core spec.
- **The marketplace already solves service discovery.** A bridge is just another capability: discoverable, negotiable, verifiable, payable.
- **Bridge operators can specialize.** One operator runs a Matrix bridge. Another runs SSB. A third bridges both plus Nostr. They set their own pricing and compete on quality.

```mermaid
flowchart TB
    MEHR["Mehr Network"]
    MEHR --> MB["Matrix Bridge\n(L2)"]
    MEHR --> SB["SSB Bridge\n(L2)"]
    MEHR --> NB["Nostr Bridge\n(L2)"]
    MB --> MF["Matrix Federation"]
    SB --> SP["SSB Pubs"]
    NB --> NR["Nostr Relays"]
```

Each bridge is an L2 Mehr node that also speaks an external protocol. From the Mehr side, it's a service provider. From the external side, it's a participant in that protocol's network.

## Identity Attestation

The core interop mechanism builds on [MHR-ID's ExternalIdentity claims](/docs/L5-services/mhr-id-verification#identity-linking). An ExternalIdentity claim is a signed assertion linking a Mehr identity to an external platform account, verified via [crawler or OAuth challenges](/docs/L5-services/mhr-id-verification#crawler-challenge) — the same methods used by [FUTO ID](https://docs.polycentric.io/futo-id/).

For protocol bridges specifically, the bridge node acts as a **verification oracle** — it can verify the user's external identity via OAuth and publish a vouch, just like any [verification oracle](/docs/L5-services/mhr-id-verification#verification-oracles). The bridge also stores a protocol-specific attestation for message routing:

```
BridgeAttestation {
    mehr_pubkey: Ed25519PublicKey,       // Mehr identity
    external_protocol: enum {
        Matrix, SSB, Nostr, Briar, Meshtastic, LXMF
    },
    external_identity: Vec<u8>,          // protocol-specific ID
    bridge_node: NodeID,                 // which bridge created this
    timestamp: LamportTimestamp,
    signature: Ed25519Signature,         // signed by mehr_pubkey
}
```

**How it works**:

1. Alice has a Mehr identity (Ed25519 keypair) and a Matrix account (`@alice:example.org`)
2. She publishes an `ExternalIdentity` claim for platform `matrix`, handle `@alice:example.org`
3. She connects to a Matrix bridge service, which verifies her identity via OAuth and publishes a vouch
4. The bridge stores a `BridgeAttestation` for message routing
5. Other Mehr nodes can verify the claim via trust-weighted vouches — no need to trust the bridge blindly

This is stronger than a bridge-only attestation because the ExternalIdentity claim is part of Alice's [MHR-ID profile](/docs/L5-services/mhr-id#profile-assembly) — visible to anyone who views her profile, with verification status from multiple independent oracles.

**What the bridge doesn't know**: The content of E2E encrypted messages passing through it. The bridge translates metadata and routing, not plaintext.

**What the bridge does know**: Which Mehr identity maps to which external identity. This is inherent — you can't bridge without knowing both sides. Users choose which bridges to trust with this mapping.

## Payment Flows

Bridge economics use existing Mehr primitives — no new payment mechanisms required.

### Mehr-to-External

Alice (Mehr) sends a message to Bob (Matrix):

```
Alice → [pays relay MHR] → Bridge Node → [Matrix federation, bridge pays] → Bob
```

- Alice pays Mehr-side relay costs via normal [payment channels](/docs/L3-economics/payment-channels)
- The bridge operator pays Matrix-side costs (homeserver hosting, bandwidth)
- Bridge recoups costs through service fees (per-message, subscription, or ad-supported)

### External-to-Mehr

Carol (Matrix) sends a message to Dave (Mehr):

```
Carol → [Matrix federation, free] → Bridge Node → [pays relay MHR] → Dave
```

- Carol sends via Matrix (free from her perspective)
- The bridge node bears Mehr-side relay costs
- Bridge recoups via Matrix-side monetization, donations, or operates as a public good
- Alternatively, Dave pays the bridge for inbound message delivery (pull model)

### Cross-Bridge

Alice (SSB) sends to Bob (Matrix), both connected to Mehr:

```
Alice → SSB Bridge → [Mehr relay] → Matrix Bridge → Bob
```

Both bridges participate in the Mehr network. The message traverses Mehr's mesh as ordinary encrypted traffic. Each bridge handles its own external protocol costs.

## What Makes a Good Bridge Target

Not every protocol is worth bridging. The best candidates share these properties:

| Property | Why It Matters |
|----------|---------------|
| **Decentralized identity** | Attestation works without asking permission from a central authority |
| **Offline tolerance** | Mehr's store-and-forward model maps naturally to protocols that handle delays |
| **Gossip or relay-based** | Similar distribution model; easier to translate |
| **Ed25519 or compatible crypto** | Reduces key management complexity |
| **Active community** | Bridge is only useful if people use the other side |
| **Open protocol** | Can implement a bridge without licensing or API keys |

Properties that make bridging harder:

| Property | Challenge |
|----------|-----------|
| **Requires always-on internet** | Bridge node must maintain persistent connection; can't operate in mesh-only mode |
| **Global consensus required** | Blockchain-based protocols add settlement latency and complexity |
| **Proprietary or closed** | Can't implement without reverse engineering or vendor cooperation |
| **Different encryption model** | E2E translation requires re-encryption at the bridge (breaks zero-knowledge) |

## Bridge Categories

### Transport-Level Bridges

These operate at Layer 0 — translating between Mehr's transport and another mesh protocol's transport. Packets flow between networks at the radio/link level.

**Example**: [Meshtastic](meshtastic) — LoRa mesh nodes that can forward Mehr packets as opaque payloads.

**Advantage**: Deepest integration. External nodes contribute physical infrastructure (radio coverage, relay hops) to the Mehr mesh.

**Challenge**: Requires the external protocol to support opaque payload forwarding.

### Protocol-Level Bridges

These operate at the application layer — translating messages, posts, or data between Mehr's service primitives and an external protocol's data model.

**Examples**: [Matrix](matrix) (room ↔ topic), [Scuttlebutt](scuttlebutt) (feed ↔ DHT), Nostr (event ↔ pub).

**Advantage**: No changes needed to the external protocol. The bridge is just another client/server on both sides.

> **Trade-off**
Protocol-level bridges face semantic mismatch: Mehr’s immutable DataObjects don’t map 1:1 to Matrix’s mutable room state or SSB’s append-only feeds. Each bridge needs protocol-specific translation logic, and E2E encryption breaks at the bridge boundary.

**Challenge**: Semantic mismatch. Mehr's immutable DataObjects don't map 1:1 to Matrix's mutable room state or SSB's append-only feeds. Each bridge needs protocol-specific translation logic.

### Ecosystem Bridges

These connect Mehr to protocols it already shares infrastructure with — particularly the [Reticulum ecosystem](reticulum-ecosystem).

**Example**: LXMF messages carried natively on a Reticulum-compatible transport.

**Advantage**: Near-zero translation overhead. Compatible wire format, same crypto, same transport interface.

**Challenge**: Coordinating upgrade paths as Mehr adds economic extensions and variable frame sizes that pure Reticulum nodes don't understand.

## Compatibility Landscape

### Tier 1 — High Alignment, Build First

| Project | Bridge Type | Key Alignment | Detailed Page |
|---------|------------|---------------|---------------|
| **Meshtastic** | Transport | Same LoRa hardware, massive deployed base | [Meshtastic Bridge](meshtastic) |
| **Reticulum / LXMF** | Ecosystem | Shared transport layer, native coexistence | [Reticulum Ecosystem](reticulum-ecosystem) |
| **Scuttlebutt (SSB)** | Protocol | Gossip-based, offline-first, Ed25519, aligned values | [Scuttlebutt Bridge](scuttlebutt) |

### Tier 2 — Good Fit, Build Second

| Project | Bridge Type | Key Alignment | Notes |
|---------|------------|---------------|-------|
| **BitTorrent** | Protocol | Content-addressed, massive DHT (10–25M nodes), BEP-44 uses Ed25519 | [BitTorrent Bridge](bittorrent) |
| **Matrix** | Protocol | Federated, well-specified, transitive bridge access to dozens of protocols | [Matrix Bridge](matrix) |
| **Nostr** | Protocol | Simple event model, sovereignty-focused, growing community | Relay ↔ MHR-Pub translation |
| **Yggdrasil** | Transport | Encrypted mesh overlay; alternative backbone for internet-connected nodes | Could supplement Reticulum for IP links |

### Tier 3 — Interesting, Community-Driven

| Project | Bridge Type | Key Alignment | Notes |
|---------|------------|---------------|-------|
| **IPFS / libp2p** | Protocol | Content-addressing, libp2p as alternative transport | Heavy bandwidth assumptions conflict with constrained links |
| **Briar** | Protocol | Tor-based, offline-capable, similar threat model | Tor dependency adds complexity |
| **Althea** | Protocol | Paid relay economics, shared incentive model | Ethereum dependency, different economic model |

### Tier 4 — Watch, Don't Build

| Project | Why Watch | Why Wait |
|---------|-----------|----------|
| **Holochain** | Agent-centric like Mehr, CRDT-compatible | Heavy runtime, small community |
| **GNUnet** | Privacy-focused mesh, strong academic foundation | Small community, complex protocol |
| **Dat / Hypercore** | Append-only logs, good P2P sync | Niche adoption, no incentive layer |

## What Mehr Does NOT Bridge

Some things are deliberately out of scope:

- **Cross-protocol atomic swaps.** Mehr's CRDT ledger has different finality guarantees than blockchains. Token exchange happens through gateway operators or bilateral agreement, not protocol-level swap primitives.
- **Universal identity federation.** Mehr doesn't maintain a global directory mapping all identities across all protocols. [ExternalIdentity claims](/docs/L5-services/mhr-id-verification#identity-linking) link your Mehr key to external platforms, but each bridge maintains its own routing attestations. Users choose which bridges they trust.
- **Protocol-level name resolution for external systems.** Mehr's [naming system](/docs/L5-services/mhr-name) resolves Mehr names via trust-weighted resolution. External names resolve through their own systems, with bridges translating at the boundary.
- **Backward compatibility shims.** Bridge operators handle version mismatches. The Mehr protocol doesn't adapt its wire format to accommodate external protocol changes.

## Building a Bridge

For developers wanting to create a bridge service:

1. **Run an L2 Mehr node** — full protocol stack, marketplace participation
2. **Advertise bridging as a capability** — `compute.offered_functions` includes bridge-specific function IDs
3. **Implement identity attestation** — store and serve `BridgeAttestation` records
4. **Handle message translation** — protocol-specific logic for each direction
5. **Manage payment** — collect fees via Mehr [service agreements](/docs/L4-marketplace/agreements), pay external protocol costs
6. **Gossip attestation availability** — so other Mehr nodes can discover which identities are reachable through your bridge

The bridge is a regular Mehr service. It earns MHR through service agreements, pays for relay through payment channels, and builds reputation through the [trust system](/docs/L3-economics/trust-neighborhoods). No special protocol support is needed — the marketplace handles everything.

## Roadmap Integration

Cross-network bridges are planned for [Phase 4](../development/roadmap#phase-4-full-ecosystem) (Milestone 4.3), after the core protocol, economics, mobile apps, and mesh radio are proven. This is deliberate — bridges depend on a stable, battle-tested protocol. Building bridges before the foundation is solid creates fragile integrations that break with every protocol change.

The phasing:

| Phase | Interop Activity |
|-------|-----------------|
| Phase 1 | TCP/IP transport only — servers talk to each other |
| Phase 2 | Economics validated — bridge payment model can be tested |
| Phase 3 | Multi-transport proven — bridge nodes can run on diverse hardware |
| Phase 4 | **Protocol bridges ship** — SSB, Matrix, Briar as standalone gateway services |

Early community experimentation with bridges during Phase 2-3 is encouraged — the marketplace is designed to support it. But official bridge implementations come after the protocol stabilizes.

---

### Meshtastic Bridge
<!-- Source: docs/interoperability/meshtastic.md -->

# Meshtastic Bridge

Meshtastic is the highest-priority bridge target for Mehr. Tens of thousands of LoRa nodes are already deployed worldwide — cheap, solar-powered, community-operated. A transport-level bridge between Mehr and Meshtastic gives Mehr instant access to physical radio infrastructure without waiting for dedicated Mehr hardware deployments.

## Why Meshtastic First

| Factor | Detail |
|--------|--------|
| **Same physical layer** | Both use LoRa on ISM bands (868/915 MHz). Same radios, same antennas, same propagation characteristics. |
| **Massive hardware base** | LILYGO T-Beam, Heltec WiFi LoRa 32, RAK WisBlock — the same boards listed in Mehr's [reference designs](/docs/hardware/reference-designs). Many are already deployed and powered. |
| **Low barrier** | No firmware changes needed on existing Meshtastic nodes for basic L0 relay. Bridge nodes handle translation. |
| **Complementary features** | Meshtastic provides GPS tracking, channel-based messaging, range testing. Mehr adds economics, storage, compute, and E2E encryption. |
| **Community alignment** | Open-source, community-driven, off-grid focused. Same user base. |

## Integration Architecture

The bridge operates at the **transport level** — deeper than a typical protocol bridge. Rather than translating application-layer messages, it translates at the packet/frame level, allowing Meshtastic nodes to participate as physical infrastructure in the Mehr mesh.

### Three Integration Modes

#### Mode 1: Meshtastic as L0 Transport (Opaque Relay)

Meshtastic nodes forward Mehr packets as opaque payloads without understanding them.

```mermaid
flowchart LR
    L2A["Mehr L2 Node"] --> BA["Bridge Node\nMehr L1 + MT"]
    BA --> MT1["MT Node\n(L0)"]
    MT1 --> MT2["MT Node\n(L0)"]
    MT2 --> MT3["MT Node\n(L0)"]
    MT3 --> BB["Bridge Node\nMehr L1 + MT"]
    BB --> L2B["Mehr L2 Node"]
    style MT1 fill:#e8d5f5,stroke:#7b2d8e
    style MT2 fill:#e8d5f5,stroke:#7b2d8e
    style MT3 fill:#e8d5f5,stroke:#7b2d8e
```

**How it works**:

1. Bridge node runs dual firmware: Mehr L1 + Meshtastic
2. Mehr packet arrives at bridge node via Mehr routing
3. Bridge encapsulates it as a Meshtastic `TEXT_MESSAGE_APP` or custom `PRIVATE_APP` portnum payload
4. Meshtastic mesh forwards it using Meshtastic's own flood/routing
5. Destination bridge node extracts the Mehr packet and delivers it to the Mehr network

**Meshtastic payload format**:

```
MehrOverMeshtastic {
    magic: u16 = 0x4D48,             // "MH" — identifies Mehr payload
    version: u8,                      // encapsulation version
    flags: u8,                        // fragmentation, priority
    fragment_id: u16,                 // for payloads exceeding Meshtastic MTU
    fragment_offset: u8,              // fragment sequence
    fragment_total: u8,               // total fragments
    payload: [u8],                    // Mehr packet (encrypted, opaque to MT nodes)
}
```

**MTU handling**: Meshtastic's maximum payload is ~228 bytes (varies by region/settings). Mehr packets that exceed this are fragmented at the bridge and reassembled at the destination bridge. The `fragment_id` field allows interleaving fragments from different Mehr packets.

**Key property**: Existing Meshtastic nodes require **zero changes**. They see a Meshtastic packet and forward it like any other. The Mehr content is opaque — encrypted and meaningless to nodes that don't understand it.
> **Key Insight**
Mode 1 (opaque relay) gives Mehr instant access to the entire deployed Meshtastic network with zero firmware changes. Existing nodes forward Mehr packets as regular Meshtastic messages — they never need to understand the content.

#### Mode 2: Meshtastic Nodes as Mehr L0 (Firmware Extension)

A lightweight firmware module lets Meshtastic nodes understand Mehr's announce format and participate in Mehr routing as L0 transport nodes.

```mermaid
flowchart LR
    A["Mehr L2"] <--> B["Mehr L1"]
    B <--> C["MT + L0\nMehr L0 module"]
    C <--> D["MT + L0\nMehr L0 module"]
    D <--> E["Mehr L1"]
    E <--> F["Mehr L2"]
    style C fill:#e8d5f5,stroke:#7b2d8e
    style D fill:#e8d5f5,stroke:#7b2d8e
```

**What the L0 module does**:

- Recognizes Mehr announce packets (by magic bytes in the Meshtastic payload)
- Forwards them using Meshtastic's mesh routing (opaque byte forwarding)
- Reports link quality metrics (RSSI, SNR, hop count) that bridge nodes translate to [CompactPathCost](/docs/L1-network/network-protocol#mehr-extension-compact-path-cost)
- Does NOT parse economic extensions, run VRF lottery, or maintain payment channels

**Implementation**: ~2-5 KB of additional firmware on ESP32. The module hooks into Meshtastic's packet receive/forward pipeline and recognizes the `0x4D48` magic prefix.

**Benefit over Mode 1**: Better routing decisions. L0-aware Meshtastic nodes can prioritize Mehr traffic and report accurate link metrics, rather than treating Mehr packets as generic messages competing with Meshtastic traffic.

#### Mode 3: Dual-Protocol Node (Full Convergence)

A single device runs both Meshtastic and Mehr L1, sharing the same LoRa radio via time-division.

```mermaid
flowchart TB
    subgraph node["Dual-Protocol Node"]
        direction TB
        subgraph stacks[" "]
            direction LR
            MT["Meshtastic\nStack"]
            MEHR["Mehr L1\nStack"]
        end
        TDMA["Radio Time-Division\nManager (TDMA/slot)"]
        RADIO["LoRa Radio\nSX1262/76"]
    end
    MT --> TDMA
    MEHR --> TDMA
    TDMA --> RADIO
```

**Time-division approach**:

- Radio time is split between Meshtastic and Mehr traffic
- Default: 70% Meshtastic / 30% Mehr (configurable)
- Priority override: Mehr relay lottery wins get immediate transmission
- Listen periods are shared — both stacks receive all packets

**Why time-division, not frequency-division**: Most LoRa nodes have a single radio on a single frequency. Frequency splitting would halve bandwidth for both protocols. Time-division preserves full bandwidth for whichever protocol is transmitting.

**Target hardware**: ESP32-S3 with SX1262 (e.g., Heltec WiFi LoRa 32 V3, LILYGO T-Beam Supreme). These have enough flash (8 MB) and RAM (512 KB) for both stacks.

## Bridge Node Specification

A Meshtastic-Mehr bridge node is a physical device that participates in both networks. Minimum requirements:

| Component | Requirement |
|-----------|------------|
| **MCU** | ESP32-S3 (dual-core, 512 KB SRAM, 8 MB flash) |
| **Radio** | SX1262 LoRa transceiver |
| **Firmware** | Meshtastic + Mehr L1 (Mode 2 or 3) |
| **Power** | Solar viable (bridge adds ~15% power consumption over base Meshtastic) |
| **Cost** | $15-30 (same hardware as existing Meshtastic nodes) |

### Bridge Capabilities Advertised

The bridge node advertises itself in the Mehr [capability marketplace](/docs/L4-marketplace/overview):

```
NodeCapabilities {
    connectivity: {
        bandwidth_bps: 1200,          // LoRa link speed
        latency_ms: 2000,             // typical LoRa hop latency
        cost_per_byte: 10,            // μMHR per byte (higher than WiFi)
        internet_gateway: false,
    },
    bridge: {
        protocols: [Meshtastic],
        meshtastic_channels: 8,       // number of MT channels bridged
        meshtastic_region: "US",      // regulatory region
        mt_node_count: 23,            // known MT nodes reachable
    },
    availability: Solar,              // or AlwaysOn if grid-powered
}
```

### Routing Cost Translation

Meshtastic provides hop count and SNR. Mehr needs [CompactPathCost](/docs/L1-network/network-protocol#mehr-extension-compact-path-cost). The bridge translates:

```
CompactPathCost from Meshtastic metrics:
    cumulative_cost = base_lora_cost × mt_hop_count
    worst_latency_ms = mt_hop_count × avg_lora_hop_latency
    bottleneck_bps = lora_datarate (from Meshtastic region config)
    hop_count = mt_hop_count + mehr_hop_count
```

This lets Mehr's [cost-weighted routing](/docs/L1-network/network-protocol#routing) make informed decisions about paths that traverse Meshtastic segments. A Mehr node choosing between a 3-hop WiFi path and a 2-hop Meshtastic path can compare costs accurately.

## Message Translation

### Mehr-to-Meshtastic

For users who want to reach Meshtastic contacts from Mehr:

1. Mehr user sends message to a Meshtastic destination (identified by bridge attestation)
2. Bridge node receives the Mehr packet, decrypts the transport layer
3. Bridge re-encrypts for the Meshtastic channel (PSK-based, per Meshtastic's model)
4. Message delivered as a standard Meshtastic text message
5. Meshtastic recipient sees: `[MHR:alice] Hello from the other side`

**Security note**: E2E encryption breaks at the bridge. Mehr uses per-recipient Ed25519-based encryption; Meshtastic uses shared channel PSK. The bridge must decrypt and re-encrypt. Users are warned that messages crossing the bridge are readable by the bridge operator. For sensitive content, both parties should be on the same protocol.

> **Trade-off**
The Meshtastic bridge is trust-sensitive: E2E encryption terminates at the bridge node. The bridge operator can read plaintext of all messages crossing protocols. For sensitive conversations, both parties must be on the same protocol — the bridge is only suitable for non-confidential traffic.

### Meshtastic-to-Mehr

1. Meshtastic user sends a message on a bridged channel
2. Bridge node receives the Meshtastic packet
3. If the message targets a Mehr user (prefix `@mehr:` or configured mapping), bridge translates
4. Bridge encrypts E2E for the Mehr recipient and sends via Mehr routing
5. Bridge pays Mehr relay costs from its own balance

### Position and Telemetry

Meshtastic nodes broadcast GPS position and device telemetry. Bridges can optionally translate this:

- **Position** → Mehr `GeoPresence` claim (with consent — GPS data is sensitive)
- **Telemetry** → Mehr node health metrics (battery, temperature, signal quality)
- **Traceroute** → Contributes to Mehr's routing cost estimates for Meshtastic segments

This data flows one-way (Meshtastic → Mehr) unless the Meshtastic user has explicitly opted into Mehr identity attestation.

## Migration Path

For Meshtastic community members who want to adopt Mehr incrementally:

### Stage 1: Passive Bridge (Zero Changes)

- A community member deploys a bridge node alongside existing Meshtastic infrastructure
- Meshtastic nodes continue operating normally
- Bridge forwards Mehr traffic as opaque Meshtastic payloads (Mode 1)
- Meshtastic users notice nothing different
- Mehr users gain LoRa coverage through the Meshtastic mesh

### Stage 2: Awareness (Optional Firmware Update)

- Interested Meshtastic operators flash the L0-aware firmware extension
- Their nodes start reporting link quality to bridge nodes
- Mehr routing improves across Meshtastic segments
- No economic participation yet — pure transport contribution

### Stage 3: Economic Participation (L1 Upgrade)

- Operators who want to earn MHR upgrade to dual-protocol firmware (Mode 3)
- Their nodes participate in the VRF relay lottery
- Relay wins earn MHR through [payment channels](/docs/L3-economics/payment-channels)
- A $20 solar LoRa node becomes a revenue-generating relay

### Stage 4: Full Mehr (L2)

- Operators with Raspberry Pi or better hardware run full Mehr nodes
- Participate in storage, compute, and marketplace
- Meshtastic continues as one of their radio interfaces
- They are now bridge operators, earning from both relay and bridge services

Each stage is optional. A community can stay at Stage 1 indefinitely — Mehr gets radio coverage, Meshtastic users experience no disruption. The upgrade path exists for those who want economic participation.

## Meshtastic Protocol Considerations

### Channel Allocation

Meshtastic supports up to 8 channels. The bridge uses one channel for Mehr traffic:

| Channel | Use |
|---------|-----|
| 0 | Default Meshtastic (LongFast, community) |
| 1-6 | User-configured Meshtastic channels |
| 7 | Mehr bridge traffic (configurable) |

The Mehr bridge channel uses a well-known PSK derived from the bridge node's public key. Meshtastic nodes that don't understand Mehr simply ignore traffic on this channel (standard Meshtastic behavior — unknown channels are not displayed).

### Regional Compliance

Meshtastic enforces regional LoRa parameters (frequency, bandwidth, duty cycle) per its firmware configuration. The bridge inherits these constraints:

- **EU868**: 1% duty cycle limits → Mehr traffic budgeted within this limit
- **US915**: More permissive → higher Mehr throughput available
- **Duty cycle accounting**: Bridge tracks airtime for both Meshtastic and Mehr traffic combined, never exceeding regional limits

### Mesh Routing Interaction

Meshtastic uses a managed flood routing protocol. Mehr uses [Kleinberg small-world routing](/docs/L1-network/network-protocol#routing). These models differ fundamentally:

- **Meshtastic**: Broadcast-oriented, packets flood to all reachable nodes
- **Mehr**: Unicast-oriented, packets follow cost-optimal paths

The bridge resolves this mismatch:

- **Mehr → Meshtastic**: Bridge sends as Meshtastic direct message (unicast within Meshtastic's routing) when possible, or broadcast on the bridge channel for unknown destinations
- **Meshtastic → Mehr**: Bridge receives all Meshtastic traffic on the bridge channel, forwards only packets addressed to Mehr destinations

## Hardware Compatibility

All hardware listed in Meshtastic's [supported devices](https://meshtastic.org/docs/hardware/devices/) is compatible with Mode 1 (opaque relay — no firmware changes). Mode 2 and 3 require firmware space:

| Device | Mode 1 | Mode 2 (L0) | Mode 3 (Dual) | Notes |
|--------|--------|-------------|---------------|-------|
| Heltec V3 | Yes | Yes | Yes | 8 MB flash, good for dual stack |
| LILYGO T-Beam | Yes | Yes | Yes | GPS included, solar-ready |
| RAK WisBlock | Yes | Yes | Yes | Modular, industrial use |
| Heltec V2 | Yes | Yes | Limited | 4 MB flash, tight for dual |
| nRF52840 boards | Yes | Partial | No | Different MCU, limited flash |

**Recommended bridge hardware**: LILYGO T-Beam Supreme S3 — ESP32-S3, SX1262, GPS, solar charging circuit, 8 MB flash. ~$30, solar-capable, proven in Meshtastic deployments.

---

### Reticulum Ecosystem
<!-- Source: docs/interoperability/reticulum-ecosystem.md -->

# Reticulum Ecosystem

Mehr is built on [Reticulum](https://reticulum.network/). This isn't a bridge — it's coexistence. Mehr extends Reticulum with economic primitives, storage, compute, and a capability marketplace. Pure Reticulum applications (LXMF, Sideband, NomadNet) already share the same transport layer. The question isn't *how to bridge* but *how to coexist gracefully and offer an upgrade path*.

## The Relationship

```mermaid
flowchart TB
    subgraph transport["Shared Transport — Reticulum Wire Protocol"]
        direction LR
        RE["Pure Reticulum\n(LXMF, Sideband,\nNomadNet)\n**L0**"]
        L1["Mehr L1\n(Relay +\neconomy)\n**L1**"]
        L2["Mehr L2\n(Full\nstack)\n**L2**"]
    end
```

All three participation levels share the same Reticulum transport. An L0 node running Sideband and an L2 node running full Mehr relay packets for each other on the same mesh. They use the same encryption, the same announce mechanism, the same link establishment protocol.

Mehr's economic extensions ([CompactPathCost](/docs/L1-network/network-protocol#mehr-extension-compact-path-cost), VRF lottery proofs, settlement records) are carried as opaque payload in Reticulum's announce DATA field. Pure Reticulum nodes forward these announces without parsing the Mehr-specific bytes — they just see more data in the announce and relay it.

## LXMF Compatibility

[LXMF](https://github.com/markqvist/LXMF) (Lightweight Extensible Message Format) is Reticulum's message layer. Sideband and NomadNet use LXMF for messaging.

### How Messages Coexist

LXMF messages and Mehr messages both travel over Reticulum links. They are distinguished by their Reticulum **aspect** — the application identifier in the destination hash:

| Message Type | Reticulum Aspect | Handling |
|-------------|-----------------|----------|
| LXMF message | `lxmf.delivery` | Processed by LXMF-aware applications |
| Mehr DataObject | `mehr.store` | Processed by Mehr L2 nodes |
| Mehr Pub notification | `mehr.pub` | Processed by Mehr L2 nodes |

A node running both Sideband and Mehr L2 handles both aspects simultaneously. LXMF messages arrive through the LXMF stack. Mehr messages arrive through the Mehr stack. Same radio, same transport, different application handlers.

### LXMF-to-Mehr Message Translation

For users who want Sideband contacts to receive Mehr messages (or vice versa), a bridge service translates between the two:

```
LXMF Message                    Mehr Message
┌──────────────────┐            ┌──────────────────┐
│ source_hash      │   Bridge   │ sender: NodeID   │
│ destination_hash │  ────────→ │ recipient: NodeID│
│ content          │            │ DataObject       │
│ timestamp        │            │   (immutable)    │
│ title (optional) │            │ MHR-Pub notify   │
│ fields (dict)    │            │ payment: channel │
└──────────────────┘            └──────────────────┘
```

**Translation details**:

1. **Identity**: LXMF uses Reticulum destination hashes (derived from Ed25519 keys). Mehr uses the same Ed25519 keys and the same destination hash derivation. **Identity is natively shared** — no attestation needed if the user controls the same key on both sides.

2. **Content**: LXMF `content` field → Mehr immutable DataObject (stored in [MHR-Store](/docs/L5-services/mhr-store)). LXMF `fields` dict → Mehr DataObject metadata.

3. **Delivery**: LXMF delivery → Mehr [MHR-Pub](/docs/L5-services/mhr-pub) notification. The bridge publishes a Pub notification that triggers Mehr-side delivery.

4. **Encryption**: Both use the same underlying crypto (X25519 ECDH + symmetric cipher). LXMF link encryption maps directly to Reticulum link encryption, which is the same link encryption Mehr uses. No re-encryption needed at the bridge for transport-layer security. E2E encryption differs: LXMF uses Reticulum's built-in E2E; Mehr uses its own envelope format. The bridge re-wraps E2E content.

### Shared Identity (Zero-Cost Bridge)

Because LXMF and Mehr both derive identity from Ed25519 keypairs via Reticulum's destination hash:

- A user with the same keypair is **the same identity** on both LXMF and Mehr
- No attestation, no bridge registration, no identity mapping
- Sideband shows your Reticulum hash. Mehr shows the same hash.
- If Alice's Sideband identity is `a1b2c3d4...`, her Mehr identity is `a1b2c3d4...`

This means a "bridge" for existing Reticulum users is really just **running Mehr alongside their existing Reticulum applications**. Same key, same identity, additional capabilities.

> **Key Insight**
LXMF and Mehr share the same Ed25519 keypair and Reticulum destination hash derivation. A user’s Sideband identity and Mehr identity are cryptographically identical — no attestation, registration, or bridge configuration needed.

## Sideband Integration

[Sideband](https://github.com/markqvist/Sideband) is the most popular Reticulum messaging application — available on Android, Linux, and macOS.

### Coexistence Path

Sideband users adopt Mehr in stages:

**Stage 1: Shared Transport (Today)**

- Sideband and Mehr daemon run on the same device
- Both register with the local Reticulum instance
- Both use the same radio interfaces
- No interaction between the two — they share transport, not data

**Stage 2: Unified Contact List**

- Mehr reads Sideband's known destinations (same key format)
- Contacts appear in both applications
- Messages between two Mehr users go through Mehr (with economics, storage)
- Messages to Sideband-only users go through LXMF (free, no economics)

**Stage 3: Mehr-Enhanced Sideband**

- Sideband plugin or fork that optionally uses Mehr services:
  - **MHR-Store** for persistent message storage (Sideband messages are ephemeral)
  - **MHR-Pub** for group notifications (Sideband has limited group support)
  - **MHR-DHT** for contact discovery beyond direct announces
  - **Payment channels** for relay incentives (Sideband relays are volunteer-only)

**Stage 4: Sideband as Mehr Frontend**

- Sideband evolves into a Mehr client application
- All messaging uses Mehr primitives
- LXMF compatibility maintained as a legacy bridge
- The Sideband UI, which is already familiar to the Reticulum community, becomes a Mehr frontend

This path is **not a hostile takeover**. Each stage is optional. Many Sideband users may never go past Stage 1, and that's fine — they're already contributing to the transport layer by running Reticulum nodes.

## NomadNet Integration

[NomadNet](https://github.com/markqvist/NomadNet) is a terminal-based communication platform on Reticulum — messaging, file sharing, and microblogging via a text-based interface.

### Bridgeable Features

| NomadNet Feature | Mehr Equivalent | Bridge Approach |
|-----------------|----------------|-----------------|
| Pages (microblog) | [Social posts](/docs/L6-applications/social) | NomadNet page → Mehr `PostEnvelope` DataObject |
| File hosting | [MHR-Store](/docs/L5-services/mhr-store) | NomadNet hosted files → Mehr DataObjects with storage agreements |
| Messaging | [Messaging](/docs/L6-applications/messaging) | LXMF translation (same as above) |
| Node directory | [MHR-DHT](/docs/L5-services/mhr-dht) | NomadNet announces → Mehr DHT entries |

NomadNet's page system (Markdown-like `.mu` format) maps naturally to Mehr's social layer. A bridge can publish NomadNet pages as Mehr social posts and vice versa — expanding the audience for NomadNet content to Mehr users.

## RNode Hardware

[RNode](https://reticulum.network/manual/hardware.html) is the reference hardware for Reticulum — a LoRa transceiver firmware that runs on common ESP32+LoRa boards. RNodes are used by both Reticulum/Sideband and can serve Mehr.

### RNode as Mehr Transport

An RNode running its standard firmware serves as a radio modem for a host running Reticulum. If that host also runs Mehr, the RNode provides LoRa transport for Mehr traffic — no RNode firmware changes needed.

```
[Raspberry Pi]
  ├── Reticulum daemon
  ├── Mehr L2 daemon
  └── USB serial ──→ [RNode (ESP32 + LoRa)]
                          │
                     LoRa radio
                          │
                     [Other nodes]
```

### RNode with Mehr L1

For standalone operation (no host computer), an RNode can be extended with Mehr L1 firmware:

- Parse CompactPathCost from announces
- Run VRF relay lottery
- Maintain minimal payment channel state (200 bytes per channel)
- Report to a nearby L2 node for settlement

This turns a $15-25 RNode into a self-contained, revenue-generating Mehr relay. The same hardware that today serves as a volunteer Reticulum modem becomes an economically incentivized node.

## Protocol Compatibility Details

### Announce Format

Reticulum announces carry a DATA field that applications can populate. Mehr uses this field for CompactPathCost and capability advertisements:

```
Reticulum Announce:
  ├── destination_hash (16 bytes)
  ├── public_key (32 bytes)
  ├── app_data (variable)       ← Mehr extensions go here
  │     ├── CompactPathCost (6 bytes)
  │     ├── capability_bitfield (2 bytes)
  │     ├── cost_tier (1 byte)
  │     └── load (1 byte)
  └── signature (64 bytes)

Total Mehr overhead in announce: ~10 bytes
```

Pure Reticulum nodes see the `app_data` field but don't parse it — they forward the announce with the field intact. Mehr-aware nodes parse it and use it for routing and marketplace decisions.

**Backward compatibility**: If a pure Reticulum application sets its own `app_data`, Mehr nodes ignore unrecognized formats. The `0x4D48` ("MH") magic prefix identifies Mehr-specific app_data.

### Link Encryption

Reticulum provides link-layer encryption:
- X25519 ECDH key exchange
- AES-256-CBC (current) or ChaCha20-Poly1305 (future)
- Counter-based nonces
- Automatic key rotation

Mehr uses this encryption directly — no additional link-layer crypto. E2E encryption is an additional layer on top, but transport security is inherited from Reticulum.

### Gossip Bandwidth

Mehr's [gossip protocol](/docs/L1-network/network-protocol#gossip-protocol) operates within a strict bandwidth budget (10% of link capacity, tiered). On a shared Reticulum transport, this budget covers both Mehr gossip and Reticulum's native announce propagation:

| Traffic Type | Budget Allocation |
|-------------|-------------------|
| Reticulum announces (routing) | Part of Tier 1 (3%) |
| Mehr CompactPathCost gossip | Part of Tier 2 (3%) |
| Mehr service/DHT/pub gossip | Tier 3 (2%) |
| Mehr social/trust gossip | Tier 4 (2%) |
| LXMF message delivery | User traffic (90% budget) |
| Mehr data transfer | User traffic (90% budget) |

LXMF messages and Mehr data transfers share the 90% user traffic budget. On constrained LoRa links, Mehr's priority queuing ensures high-priority messages (both LXMF and Mehr) are delivered first.

## Community Considerations

The Reticulum community values simplicity, volunteer operation, and freedom from economic coercion. Mehr's economic layer could be seen as contradicting these values. The coexistence model addresses this:

1. **Opt-in economics**: No Reticulum user is forced to participate in Mehr economics. Running a pure Reticulum node alongside Mehr nodes works perfectly — L0 participation with zero economic overhead.

2. **Free between friends**: Mehr's [trust-based free tier](/docs/L3-economics/trust-neighborhoods) means a local Reticulum community can adopt Mehr and still relay for free among trusted peers. Economics only activate when traffic crosses trust boundaries.

3. **No protocol tax**: Mehr doesn't charge existing Reticulum traffic. LXMF messages between two Sideband users continue to flow for free even on a link shared with Mehr traffic.

4. **Volunteer operation remains viable**: Operators who want to relay without earning MHR simply run as L0 (or L1 with lottery earnings they ignore). The protocol doesn't require economic participation.

5. **Upstream contribution**: Mehr development benefits Reticulum — performance improvements, hardware support, and testing capacity flow back to the transport layer.

The goal is to be a **superset**, not a replacement. Reticulum is excellent at what it does. Mehr adds what it doesn't do (economics, storage, compute) without diminishing what it already provides.
> **Trade-off**
Mehr’s economic layer risks alienating the Reticulum community, which values volunteer operation and simplicity. The coexistence model mitigates this: economics are strictly opt-in, LXMF traffic remains free, and L0 participation requires zero economic overhead.


---

### Scuttlebutt Bridge
<!-- Source: docs/interoperability/scuttlebutt.md -->

# Scuttlebutt Bridge

[Scuttlebutt](https://scuttlebutt.nz/) (SSB) is the protocol most philosophically aligned with Mehr. Both are gossip-based, offline-first, community-centric, and built on Ed25519 cryptographic identity. Both reject global consensus in favor of local-first operation. Both believe social networks should emerge from relationships, not platforms.

The differences are complementary: SSB has a mature social ecosystem with thousands of users. Mehr has economic incentives, radio mesh transport, and a capability marketplace. A bridge between them lets each side benefit from what the other provides.

> **Key Insight**
SSB and Mehr are the two most aligned protocols in the decentralized ecosystem: both are gossip-based, offline-first, Ed25519-identity, and reject global consensus. Their differences — SSB has the social network, Mehr has the economic layer — are complementary rather than competing.

## Protocol Alignment

| Property | SSB | Mehr | Compatibility |
|----------|-----|------|---------------|
| **Identity** | Ed25519 keypair → feed ID (`@...=.ed25519`) | Ed25519 keypair → destination hash | High — same key type, different derivation |
| **Data model** | Append-only signed log per identity | Immutable/mutable DataObjects in DHT | Moderate — log entries map to DataObjects |
| **Replication** | Social graph-based gossip (friends + friends-of-friends) | DHT + Pub/Sub + trust neighborhoods | Moderate — different scoping models |
| **Discovery** | LAN broadcast, pub servers, room servers | [Concentric ring discovery](/docs/L4-marketplace/discovery), DHT lookup | Low friction — bridge advertises in marketplace |
| **Encryption** | Secret Handshake (SHS) for connections, private-box for DMs | X25519 ECDH link encryption, E2E per-message | Compatible — both use Curve25519-derived keys |
| **Offline tolerance** | Excellent — feeds are self-contained | Excellent — store-and-forward, partition-tolerant | Native alignment |
| **Economics** | None — volunteer pubs | MHR token, VRF relay lottery, CRDT ledger | Bridge handles economic boundary |

## Identity Bridge

SSB and Mehr both use Ed25519 — but derive identities differently.

**SSB**: Feed ID = base64-encoded Ed25519 public key, prefixed with `@` and suffixed with `.ed25519`
```
@pAhDFHPLFCKPAlGrOAO9Pn5GBlsVsCj6EZLbT8FMCVU=.ed25519
```

**Mehr**: Destination hash = truncated Blake3 hash of the Ed25519 public key (16 bytes)
```
a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6
```

### Key Reuse vs. Key Attestation

Two approaches:

**Option A: Same Keypair (Recommended for new users)**

A user generates one Ed25519 keypair and uses it for both SSB and Mehr. Their SSB feed ID and Mehr destination hash both derive from the same public key. The bridge can verify this cryptographically:

```
Verify same key:
    ssb_pubkey = base64_decode(ssb_feed_id)
    mehr_destination = Blake3(mehr_pubkey)[0:16]
    assert ssb_pubkey == mehr_pubkey  // same key → same person
```

No attestation needed. The bridge just verifies the math.

**Option B: Separate Keypairs (Existing SSB users)**

Users who already have an SSB identity create a separate Mehr keypair and link them via attestation:

```
SSBBridgeAttestation {
    mehr_pubkey: Ed25519PublicKey,
    ssb_feed_id: String,              // "@...=.ed25519"
    proof_ssb: SSBMessage,            // signed SSB message containing mehr_pubkey
    proof_mehr: Ed25519Signature,     // Mehr key signs ssb_feed_id
    bridge_node: NodeID,
    timestamp: LamportTimestamp,
}
```

Both keys sign the other's identifier — bidirectional proof of ownership. The bridge stores these attestations and serves them to either network on request.

## Data Model Translation

### SSB Feeds → Mehr DataObjects

SSB organizes data as append-only logs. Each user has one feed — a sequence of signed JSON messages. Mehr organizes data as content-addressed DataObjects stored in a DHT.

```
SSB Feed Message                    Mehr DataObject
┌──────────────────────┐            ┌──────────────────────┐
│ previous: %hash      │            │ hash: Blake3(content) │
│ author: @feedID      │            │ owner: NodeID         │
│ sequence: 42         │            │ type: Immutable       │
│ timestamp: 1706...   │            │ created: Lamport(ts)  │
│ content: {           │   Bridge   │ data: {               │
│   type: "post",      │  ────────→ │   ssb_type: "post",   │
│   text: "Hello SSB", │            │   text: "Hello SSB",  │
│   channel: "#mehr"   │            │   scope: "topic:mehr", │
│ }                    │            │   ssb_sequence: 42,   │
│ signature: ...       │            │   ssb_previous: %hash │
│                      │            │ }                     │
└──────────────────────┘            └──────────────────────┘
```

**Translation rules**:

| SSB Field | Mehr Field | Notes |
|-----------|-----------|-------|
| `author` | `owner` | Mapped via identity bridge |
| `sequence` | Stored in metadata | Preserves SSB ordering |
| `previous` | Stored in metadata | Preserves SSB feed chain |
| `content.type` | DataObject metadata | `post`, `contact`, `vote`, `about` |
| `content.text` | DataObject data | Unmodified content |
| `content.channel` | [Scope](/docs/L3-economics/trust-neighborhoods) | `#channel` → `topic:channel` |
| `content.mentions` | DataObject references | Hash references to other objects |
| `signature` | Stored alongside | SSB signature preserved for verification |

**Key invariant**: The bridge preserves SSB's append-only property. Each SSB message becomes an immutable Mehr DataObject. The SSB `previous` hash chain is stored in metadata so the full feed can be reconstructed from Mehr's DHT.

### Mehr DataObjects → SSB Messages

Going the other direction, Mehr social posts become SSB feed messages:

1. Bridge receives a Mehr [social post](/docs/L6-applications/social) (`PostEnvelope` DataObject)
2. Bridge translates it into an SSB message on its own feed (bridge identity)
3. SSB message `content.text` includes the post text
4. SSB message `content.mentions` includes a reference to the Mehr author
5. SSB users see: `[mehr:a1b2c3d4] posted: "Hello from Mehr mesh"`

**Attribution**: The bridge's SSB feed clearly attributes content to Mehr authors. SSB users can follow the bridge feed to see all Mehr-bridged content, or use clients that display bridged content inline.

### Private Messages

SSB uses `private-box` (asymmetric encryption for up to 7 recipients). Mehr uses per-recipient E2E encryption.

**Bridge handling**: Private messages require re-encryption at the bridge. The bridge decrypts from one format and re-encrypts in the other. This means:

> **Threat**
Private messages crossing the SSB–Mehr bridge require re-encryption. The bridge operator can read plaintext during translation. For sensitive conversations, both parties should use the same protocol or establish a sealed E2E channel through the bridge.

- The bridge operator can read private messages that cross the bridge
- Users are warned about this trust requirement
- For truly sensitive conversations, both parties should use the same protocol
- Bridge can optionally support a **sealed mode** where both parties establish an E2E channel through the bridge using Mehr's native E2E, with the bridge only translating the routing

## Gossip Model Translation

SSB and Mehr both use gossip — but scope it differently.

### SSB Gossip

SSB replicates feeds based on social graph:
- **Hops = 1**: Replicate feeds of accounts you follow
- **Hops = 2**: Replicate feeds of accounts your follows follow
- **Hops = 3**: Broader network awareness (optional, bandwidth-heavy)

Each SSB node has a different view of the network, determined by who it follows.

### Mehr Gossip

Mehr gossips based on [concentric rings](/docs/L4-marketplace/discovery):
- **Ring 0**: Direct neighbors (full detail)
- **Ring 1**: 2-3 hops (summarized capabilities)
- **Ring 2**: Trust neighborhood (periodic)
- **Ring 3**: Beyond neighborhood (on-demand)

### Bridge Translation

The bridge reconciles these models:

```
SSB social graph    →  Mehr trust graph
─────────────────     ─────────────────
follow(@alice)     →  trust_peer(alice_mehr_id)
block(@bob)        →  (no Mehr equivalent — bridge filters)
hops=2 replication →  Ring 1 gossip scope
pub server         →  Bridge node (L2 service)
```

**SSB follows → Mehr trust**: When an SSB user follows an account that has a Mehr bridge attestation, the bridge can optionally add them to the Mehr trust graph. This is **not automatic** — it requires user consent, since Mehr trust relationships have economic implications (free relay).

**SSB channels → Mehr scopes**: SSB channels (`#topic`) map to Mehr topic scopes (`topic:topic`). The bridge subscribes to relevant SSB channels and publishes/relays content to the corresponding Mehr scopes.

## Bridge Architecture

```
┌─────────────────────────────────────────┐
│            SSB-Mehr Bridge Node          │
│                                          │
│  ┌──────────────┐  ┌──────────────────┐ │
│  │  SSB Stack    │  │   Mehr L2 Stack  │ │
│  │              │  │                  │ │
│  │ • ssb-db2    │  │ • MHR-Store     │ │
│  │ • ssb-conn   │  │ • MHR-DHT      │ │
│  │ • ssb-friends│  │ • MHR-Pub      │ │
│  │ • ssb-blobs  │  │ • Marketplace   │ │
│  └──────┬───────┘  └────────┬─────────┘ │
│         │                    │           │
│  ┌──────┴────────────────────┴─────────┐ │
│  │        Translation Layer             │ │
│  │                                      │ │
│  │  • Identity attestation registry    │ │
│  │  • Feed ↔ DataObject translator     │ │
│  │  • Channel ↔ Scope mapper           │ │
│  │  • Blob ↔ DataObject mapper         │ │
│  │  • Private message re-encryptor     │ │
│  └──────────────────────────────────────┘ │
│                                          │
│  Advertised capability:                  │
│    bridge.protocols: [SSB]               │
│    bridge.ssb_feeds_indexed: 1,234       │
│    bridge.ssb_channels: [mehr, ...]      │
└─────────────────────────────────────────┘
```

**Hardware requirements**: Raspberry Pi 4 or equivalent. SSB's database (ssb-db2) and Mehr's full L2 stack both need storage and memory. Minimum 2 GB RAM, 32 GB storage.

**Not suitable for ESP32**: SSB requires JavaScript (ssb-db2 is Node.js) or Go (go-ssb). Neither runs on microcontrollers. The bridge is an L2 service, not a constrained-device operation.

## SSB Blob ↔ Mehr DataObject

SSB stores binary content (images, files) as blobs — content-addressed by SHA-256 hash. Mehr stores content as DataObjects — content-addressed by Blake3 hash.

```
SSB Blob                          Mehr DataObject
────────                          ───────────────
&hash.sha256  ←── rehash ──→  Blake3(content)
```

**Bridge approach**:

1. SSB blob arrives at bridge
2. Bridge stores it as a Mehr immutable DataObject (Blake3-addressed)
3. Bridge maintains a mapping: `sha256_hash → blake3_hash`
4. Mehr users request by Blake3 hash; SSB users request by SHA-256 hash
5. Bridge serves both, translating the hash reference

**Bandwidth consideration**: Blobs (images, files) are large. On constrained Mehr links (LoRa), the bridge respects Mehr's `min_bandwidth` field — large blobs are only replicated to nodes with sufficient bandwidth. Metadata (post text, references) flows everywhere; blobs flow only where bandwidth permits.

## Practical Scenarios

### Alice (SSB) posts to #mesh channel

1. Alice publishes on SSB: `{ type: "post", text: "Great LoRa range today", channel: "#mesh" }`
2. Bridge replicates Alice's feed (follows Alice on SSB)
3. Bridge creates Mehr DataObject with scope `topic:mesh`
4. Mehr users subscribed to `topic:mesh` via [MHR-Pub](/docs/L5-services/mhr-pub) receive the post
5. Mehr users see Alice's post attributed to her SSB identity (via bridge attestation)

### Bob (Mehr) sends a DM to Alice (SSB)

1. Bob looks up Alice's Mehr identity via bridge attestation in [MHR-DHT](/docs/L5-services/mhr-dht)
2. Bob sends E2E encrypted message to bridge, addressed to Alice's Mehr-side identity
3. Bridge decrypts, re-encrypts with Alice's SSB public key (private-box)
4. Bridge publishes as SSB private message on its own feed, encrypted for Alice
5. Alice's SSB client decrypts and displays the message

### Community mesh (Mehr) shares content with SSB Scuttleverse

1. Community operates a local Mehr mesh with LoRa relays
2. Bridge node has both LoRa (Mehr mesh) and internet (SSB pubs) connectivity
3. Local posts tagged `topic:community-name` are translated to SSB channel `#community-name`
4. Global SSB users discover the community's content through the bridge's SSB feed
5. SSB replies flow back through the bridge to the local Mehr mesh

## Why SSB Before Other Social Protocols

| Factor | SSB | Nostr | Mastodon/ActivityPub |
|--------|-----|-------|---------------------|
| **Offline-first** | Native — designed for it | No — requires relay connectivity | No — requires server |
| **Gossip-based** | Yes — social graph replication | No — relay-based | No — HTTP federation |
| **Ed25519 identity** | Yes | No (secp256k1) | No (server-issued) |
| **No server dependency** | Yes (pubs optional) | Relays required | Server required |
| **Community ethos** | Aligned — off-grid, community, privacy | Partially aligned | Different philosophy |
| **Partition tolerant** | Excellent | Moderate | Poor |

SSB is the closest match to Mehr's design philosophy. Bridging SSB first creates the strongest ideological and technical alignment, and the SSB community is most likely to appreciate what Mehr adds (economic incentives for the infrastructure they currently run as volunteers).

---

### Matrix Bridge
<!-- Source: docs/interoperability/matrix.md -->

# Matrix Bridge

[Matrix](https://matrix.org/) is the strategic bridge target for Mehr. Not because Matrix is the most philosophically aligned protocol — [Scuttlebutt](scuttlebutt) holds that distinction — but because Matrix is the **most connected**. Matrix's federation protocol already bridges to IRC, Slack, Discord, Signal, Telegram, WhatsApp, and dozens of other platforms. A single Mehr↔Matrix bridge gives Mehr transitive access to all of them.

```mermaid
flowchart LR
    MM["Mehr Mesh"] --> MMB["Mehr↔Matrix\nBridge"]
    MMB --> MN["Matrix\nNetwork"]
    MN --> MPB["Matrix↔Platform\nBridges"]
    MPB --> Slack
    MPB --> Discord
    MPB --> IRC
    MPB --> Signal
    MPB --> Telegram
```

One bridge. Dozens of reachable networks. This is the multiplier effect.

> **Key Insight**
Matrix is the strategic bridge target because of its transitive connectivity. A single Mehr↔Matrix bridge gives Mehr access to IRC, Slack, Discord, Signal, Telegram, and every other platform Matrix already bridges to — one integration, dozens of networks.

## Why Matrix

| Property | Value for Mehr |
|----------|---------------|
| **Open standard** | Fully specified ([spec.matrix.org](https://spec.matrix.org/)), no vendor lock-in |
| **Federation** | No central server — homeservers federate like email. Bridge runs its own homeserver. |
| **E2E encryption** | Olm/Megolm (Double Ratchet-based). Widely deployed. |
| **Rich ecosystem** | Element, FluffyChat, Nheko, Cinny — dozens of clients across all platforms |
| **Bridge infrastructure** | Mature bridge ecosystem via [matrix-appservice-bridge](https://github.com/matrix-org/matrix-appservice-bridge) |
| **Room model** | Rooms are the unit of communication — maps to Mehr's pub/sub topics |
| **DAG-based state** | Room state is a directed acyclic graph (not a linear chain). Handles concurrent events. |
| **Active development** | Matrix 2.0 (sliding sync, OIDC, VoIP) actively evolving |

**What Matrix lacks that Mehr provides**: Offline operation, mesh radio transport, constrained-device support, economic incentives, partition tolerance. Matrix assumes always-on internet — a Mehr bridge extends Matrix's reach to off-grid communities.

## Architecture

The Mehr↔Matrix bridge is an L2 Mehr node that also runs a Matrix homeserver (or connects to one as an application service).

### Deployment Options

**Option A: Bridge with Embedded Homeserver (Recommended)**

The bridge runs its own lightweight Matrix homeserver (e.g., [Conduit](https://conduit.rs/) — written in Rust, low resource usage):

```
┌──────────────────────────────────────────┐
│          Mehr↔Matrix Bridge Node          │
│                                           │
│  ┌──────────────┐  ┌───────────────────┐ │
│  │  Mehr L2      │  │  Conduit          │ │
│  │  Stack        │  │  (Matrix HS)      │ │
│  │               │  │                   │ │
│  │  • MHR-Store  │  │  • Federation     │ │
│  │  • MHR-Pub    │  │  • Room state     │ │
│  │  • MHR-DHT    │  │  • E2E (Megolm)   │ │
│  │  • Marketplace│  │  • Media store    │ │
│  └──────┬────────┘  └────────┬──────────┘ │
│         │                     │            │
│  ┌──────┴─────────────────────┴──────────┐ │
│  │         Translation Layer              │ │
│  │                                        │ │
│  │  • Room ↔ Topic mapper                │ │
│  │  • User ↔ Identity attestation        │ │
│  │  • Message format translator          │ │
│  │  • Media ↔ DataObject mapper          │ │
│  │  • E2E re-encryption handler          │ │
│  └────────────────────────────────────────┘ │
│                                           │
│  Internet ←→ Matrix federation            │
│  Mesh     ←→ Mehr network                 │
└──────────────────────────────────────────┘
```

**Advantage**: Self-contained. The bridge controls its own homeserver, can operate in restricted federation mode, and doesn't depend on external homeserver operators.

**Option B: Application Service on Existing Homeserver**

The bridge registers as a [Matrix application service](https://spec.matrix.org/latest/application-service-api/) on an existing homeserver (e.g., a community Synapse/Dendrite instance):

```
[Existing Homeserver] ←─ appservice ─→ [Mehr Bridge] ←─ mesh ─→ [Mehr Network]
```

**Advantage**: Uses existing homeserver infrastructure. Community that already runs a Matrix server adds Mehr connectivity with just the bridge component.

**Disadvantage**: Depends on external homeserver operator. Bridge availability tied to homeserver uptime.

## Room ↔ Topic Mapping

Matrix rooms map to Mehr [MHR-Pub](/docs/L5-services/mhr-pub) topics and [scope subscriptions](/docs/L3-economics/trust-neighborhoods).

### Mapping Rules

```
Matrix Room                        Mehr Equivalent
───────────                        ───────────────
#general:example.org          →    topic:general
#portland-mesh:example.org    →    geo:us/oregon/portland
#dev:mehr.network             →    topic:mehr/dev
!roomid:server (unnamed)      →    topic:bridge/<room_id_hash>
```

| Matrix Concept | Mehr Concept | Translation |
|---------------|-------------|-------------|
| Room | MHR-Pub topic + scope | Bridge creates/joins corresponding topic |
| Room membership | Scope subscription | Join room → subscribe to topic |
| Message (m.room.message) | DataObject + Pub notification | Content stored in MHR-Store, notification via MHR-Pub |
| Room state events | Mutable DataObjects | Room name, topic, avatar → mutable DataObjects in DHT |
| Reactions | DataObject references | Reaction → small DataObject referencing original |
| Threads | DataObject reply chain | Thread root → DataObject; replies reference parent |
| Media (images, files) | DataObjects with MIME metadata | Stored in MHR-Store; served to Matrix via homeserver media API |

### Bidirectional Sync

**Matrix → Mehr**:

1. Bridge's homeserver receives federated events for bridged rooms
2. Translation layer converts each event to Mehr DataObjects
3. DataObjects stored in [MHR-Store](/docs/L5-services/mhr-store)
4. [MHR-Pub](/docs/L5-services/mhr-pub) notifies Mehr subscribers of the new content
5. Mehr users see Matrix messages attributed to Matrix identities (via bridge attestation)

**Mehr → Matrix**:

1. Bridge subscribes to relevant Mehr topics via MHR-Pub
2. New Mehr posts trigger translation to Matrix events
3. Bridge's homeserver sends events to bridged rooms via federation
4. Matrix users see Mehr messages attributed to virtual Matrix users (e.g., `@mehr_a1b2c3d4:bridge.mehr.network`)

### Virtual Users

The bridge creates Matrix "ghost" users for each Mehr identity that sends messages through the bridge:

```
Mehr identity: a1b2c3d4e5f6a7b8
Matrix ghost:  @mehr_a1b2c3d4:bridge.mehr.network
Display name:  "alice [Mehr]" (if Mehr profile has display name)
Avatar:        Bridged from Mehr profile (if available)
```

Matrix users can message these ghost users directly (DMs) or interact with them in rooms. The bridge translates all interactions back to Mehr.

## Identity

### Matrix → Mehr Attestation

A Matrix user wanting a Mehr identity:

1. Creates a Mehr Ed25519 keypair (or uses existing one)
2. Sends a verification message to the bridge bot in Matrix: `!mehr verify a1b2c3d4...`
3. Bridge sends a challenge to the Mehr identity
4. User signs the challenge with their Mehr key and responds
5. Bridge creates and stores the attestation:

```
MatrixBridgeAttestation {
    mehr_pubkey: Ed25519PublicKey,
    matrix_user_id: "@alice:example.org",
    bridge_node: NodeID,
    challenge: [u8; 32],
    mehr_signature: Ed25519Signature,    // Mehr key signs challenge
    matrix_proof: String,                // Matrix message ID containing Mehr pubkey
    timestamp: LamportTimestamp,
}
```

### Mehr → Matrix Attestation

A Mehr user wanting to be reachable from Matrix:

1. User connects to the bridge service on the Mehr network
2. Bridge provides a Matrix ghost user ID for their Mehr identity
3. User can optionally claim an existing Matrix account (via the challenge flow above)
4. Without claiming: messages from Mehr appear from the ghost user
5. With claiming: messages appear from their real Matrix account (bridge posts on their behalf via application service)

## Message Format Translation

### Text Messages

```
Matrix event (m.room.message):          Mehr DataObject:
{                                       {
  "type": "m.room.message",              hash: Blake3(content),
  "content": {                           owner: bridge_node_id,
    "msgtype": "m.text",                 type: Immutable,
    "body": "Hello from Matrix!",        data: {
    "format": "org.matrix.custom.html",    text: "Hello from Matrix!",
    "formatted_body": "<b>Hello</b>..."    format: "html",
  },                                       source: "matrix",
  "sender": "@alice:example.org",          sender_attestation: <hash>,
  "origin_server_ts": 1706000000000      },
}                                       }
```

**Format preservation**: Matrix supports HTML formatting. The bridge preserves this in Mehr DataObject metadata. Mehr clients that understand HTML render it; others display the plaintext `body` fallback.

### Media Messages

Matrix media (images, video, files) are uploaded to the homeserver's media repository. The bridge:

1. Downloads media from Matrix homeserver
2. Stores as Mehr immutable DataObject in [MHR-Store](/docs/L5-services/mhr-store)
3. Sets `min_bandwidth` based on file size:
   - Images below 50 KB: `min_bandwidth: 1200` (OK for LoRa)
   - Images 50 KB-1 MB: `min_bandwidth: 10000` (WiFi only)
   - Video/large files: `min_bandwidth: 100000` (broadband only)
4. Mehr clients receive metadata (filename, size, type) over any link; content downloads only when bandwidth permits

Going the other direction:

1. Mehr DataObject with media content arrives at bridge
2. Bridge uploads to its Matrix homeserver media repository
3. Bridge posts Matrix message with `mxc://` media URL
4. Matrix clients download media from the homeserver as usual

### Encrypted Messages (Megolm ↔ Mehr E2E)

Matrix E2E uses Megolm (a group ratchet). Mehr uses per-recipient E2E encryption. These are fundamentally different:

- **Megolm**: One outbound session key per sender per room. All room members decrypt with the same session key. Efficient for groups.
- **Mehr E2E**: Each message encrypted individually for each recipient's Ed25519 public key. More expensive for large groups but simpler.

**Bridge handling**:

For **E2E rooms**, the bridge must be a member of the room's Megolm session to decrypt messages. This means:

- Bridge is trusted with plaintext (same as any room member)
- Bridge decrypts from Megolm, re-encrypts with Mehr E2E for destination
- Users are warned: E2E guarantee is bridge-to-endpoint, not true end-to-end across the bridge

For **unencrypted rooms** (common for public channels), no re-encryption is needed — the bridge simply translates the message format.

> **Trade-off**
Matrix E2E (Megolm group ratchet) and Mehr E2E (per-recipient encryption) are fundamentally different. The bridge must be a Megolm session member to decrypt, making it a trust boundary. True end-to-end encryption across the bridge is not possible — only bridge-to-endpoint.

**Recommendation**: Use unencrypted Matrix rooms for public/community bridging. For private conversations that require E2E, both parties should be on the same protocol.

## Payment Flows

### Public Channel Bridging

Community rooms (public, unencrypted) bridged at the bridge operator's discretion:

```
Revenue model for bridge operator:
  • Mehr users pay per-message via service agreement (e.g., 10 μMHR/message)
  • Matrix users use the room for free (standard Matrix)
  • Bridge operator pays:
    - Homeserver hosting costs (fiat)
    - Mehr relay costs for outbound (MHR)
    - MHR-Store costs for caching Matrix content (MHR)
  • Bridge operator earns:
    - Service fees from Mehr users
    - Optionally: MHR relay rewards for hosting a well-connected node
```

### Direct Message Bridging

DMs between a Mehr user and a Matrix user:

```
Mehr user → Bridge:
  Pays per-message service fee (marketplace agreement)
  Bridge handles Matrix delivery

Matrix user → Bridge:
  Free (standard Matrix)
  Bridge pays Mehr relay costs for delivery to mesh
  Bridge recoups via:
    - Inbound delivery fee charged to Mehr recipient
    - Or subsidized as part of public bridge operation
    - Or donation-supported
```

### Self-Hosting Economics

A community running its own bridge:

- Operate a Raspberry Pi as both Matrix homeserver (Conduit) and Mehr L2 node
- Bridge their community Matrix room to their local Mehr mesh
- **Zero external cost** if all parties are in the community's [trust neighborhood](/docs/L3-economics/trust-neighborhoods) (free relay)
- Internet connectivity only needed for Matrix federation to the wider Matrix network
- If internet goes down, local Mehr mesh continues; Matrix bridge resumes when connectivity returns

## Offline and Partition Behavior

Matrix assumes persistent internet. Mehr doesn't. The bridge handles the mismatch:

### Bridge Online (Normal Operation)

- Messages flow bidirectionally in near real-time
- Matrix federation delivers to/from the bridge homeserver
- Mehr pub/sub delivers to/from mesh subscribers
- Latency: Matrix-side ~1s (internet), Mehr-side 2-30s (depending on transport)

### Bridge Offline (Internet Down, Mesh Up)

- Matrix federation stops — no new messages from Matrix network
- Mehr mesh continues operating independently
- Local Mehr users still communicate with each other
- Bridge queues outbound Matrix messages for delivery when internet returns
- On reconnection: queued messages sent, missed Matrix messages synced via federation backfill

### Bridge Partitioned (Mesh Splits)

- Mehr mesh partition: each partition's bridge node continues operating independently
- If a room is bridged by multiple bridge nodes in different partitions, each operates independently
- On partition heal: Mehr's CRDT-based state converges; duplicate messages are deduplicated by content hash

### Extended Offline

If the bridge is offline for an extended period:

- Matrix: Federation handles backfill. Bridge catches up on all missed events when it reconnects (Matrix homeservers cache events for offline servers).
- Mehr: [MHR-Store](/docs/L5-services/mhr-store) preserves messages. Bridge retrieves missed Mehr posts from the DHT on reconnection.

No messages are lost in either direction, assuming storage nodes on both sides remain operational during the outage.

## Deployment Guide

### Minimum Hardware

| Component | Specification |
|-----------|--------------|
| **Device** | Raspberry Pi 4 (2 GB RAM minimum, 4 GB recommended) |
| **Storage** | 32 GB SD card (64 GB for active communities) |
| **Network** | Internet connectivity (WiFi or Ethernet) + Mehr mesh interface |
| **Mehr interface** | USB-connected RNode (LoRa) or WiFi (for internet-only Mehr) |

### Software Stack

```
┌─────────────────────────────┐
│  Conduit (Matrix homeserver) │  Port 8448 (federation)
│  Rust, ~50 MB RAM           │  Port 443 (client API)
├─────────────────────────────┤
│  Mehr L2 daemon             │  Reticulum transport
│  Rust, ~30 MB RAM           │
├─────────────────────────────┤
│  Bridge service              │  Connects both stacks
│  Rust, ~20 MB RAM           │
└─────────────────────────────┘
  Total: ~100 MB RAM + OS
```

### Configuration

```
# bridge.toml

[matrix]
homeserver = "bridge.mehr.network"    # federation domain
port = 8448
registration_enabled = false          # ghost users only, no public registration

[mehr]
node_identity = "path/to/keyfile"
trust_config = "path/to/trust.toml"
marketplace_fee = 10                  # μMHR per bridged message

[bridge]
rooms = [
    { matrix = "#community:example.org", mehr_scope = "topic:community" },
    { matrix = "#portland:example.org", mehr_scope = "geo:us/oregon/portland" },
]
media_max_size = 5_000_000            # 5 MB max media bridge
media_min_bandwidth = 10000           # only bridge media to WiFi+ links
```

## Comparison with Existing Matrix Bridges

Matrix already has bridges to many platforms. How does a Mehr bridge compare?

| Aspect | Typical Matrix Bridge | Mehr↔Matrix Bridge |
|--------|----------------------|-------------------|
| **Transport** | Internet-only (HTTP API) | Mesh + internet (LoRa, WiFi, cellular) |
| **Availability** | Requires both sides online | Mehr side tolerates offline, store-and-forward |
| **Economics** | Free (bridge operator absorbs costs) | Service marketplace — bridge earns MHR |
| **Identity** | Platform-specific (Slack ID, Discord tag) | Cryptographic (Ed25519 attestation) |
| **E2E** | Varies (some bridges break E2E) | Explicitly handled — users warned about trust boundary |
| **Decentralized** | Bridge is a single point of failure | Multiple bridge operators possible per room |
| **Partition tolerant** | No — internet outage breaks bridge | Yes — Mehr side continues, reconciles on reconnect |

The Mehr bridge is unique in that the bridged network (Mehr) can operate independently during internet outages. This makes it particularly valuable for communities in areas with unreliable connectivity — they get Matrix-world access when internet is available and local mesh communication when it's not.

---

### BitTorrent Bridge
<!-- Source: docs/interoperability/bittorrent.md -->

# BitTorrent Bridge

[BitTorrent](https://www.bittorrent.org/) is the world's most widely deployed content distribution protocol, with 10–25 million active DHT nodes at any given time. It shares a key property with Mehr: **content addressing** — a torrent's info hash uniquely identifies its content, just as Blake3 hashes identify DataObjects in [MHR-Store](/docs/L5-services/mhr-store).

A BitTorrent bridge brings the entire BitTorrent content library into the Mehr mesh. Mesh-only users — even those on LoRa with no internet — can request torrent content through the bridge. The bridge fetches it from the BitTorrent network, verifies piece hashes, stores it as DataObjects in MHR-Store, and serves it to mesh users through normal Mehr protocols.

## Protocol Alignment

| Property | BitTorrent | Mehr | Compatibility |
|----------|-----------|------|---------------|
| **Content addressing** | SHA-1 info hash (v1) or SHA-256 Merkle root (v2) | Blake3 DataObject hash | High — both content-addressed, different hash functions |
| **Identity** | Random 20-byte peer ID (no cryptographic binding) | Ed25519 keypair → destination hash | None — BitTorrent has no identity system |
| **DHT** | Mainline DHT: Kademlia over UDP, 160-bit XOR, k=8 | [MHR-DHT](/docs/L5-services/mhr-dht): Kademlia-style, k=3, XOR + cost weighting | Moderate — same algorithmic family, different parameters |
| **Transport** | uTP (UDP) or TCP, requires IP addresses | Transport-agnostic (LoRa, WiFi, etc.), no IP required | Low — bridge must proxy between IP and mesh addressing |
| **Mutable data (BEP-44)** | Ed25519-signed DHT entries, 1 KB max, monotonic sequence | Ed25519-signed IdentityClaims, NameBindings | High — same curve, same signing pattern |
| **Encryption** | MSE/PE: obfuscation only (RC4), not security | ChaCha20-Poly1305 E2E encryption | Bridge re-encrypts at boundary |
| **Piece verification** | SHA-1 per piece (v1), SHA-256 Merkle tree (v2) | Blake3 per DataObject | Bridge verifies BT hashes, then re-hashes as Blake3 |
| **Economics** | None — volunteer seeders | MHR token, payment channels | Bridge charges for bandwidth + storage |

## Bridge Architecture

The BitTorrent bridge is a **gateway node** (internet-connected) that participates in both networks simultaneously:

```mermaid
flowchart LR
    subgraph mesh["Mehr Mesh"]
        A["Mesh Node A"]
        B["Mesh Node B"]
        C["Mesh Node C"]
    end
    A --- BR["BT Bridge\n(L2)"]
    B --- BR
    C --- BR
    subgraph internet["Internet"]
        DHT["Mainline DHT\n(UDP)"]
        BTP["BitTorrent Peers\n(uTP)"]
        TR["Trackers\n(HTTP/UDP)"]
    end
    BR --- DHT
    BR --- BTP
    BR --- TR
```

The bridge runs a full BitTorrent client (DHT, peer wire protocol, tracker announcements) and a full Mehr L2 node (MHR-Store, MHR-DHT, marketplace). It translates between the two worlds.

## Content Flow: BitTorrent → Mehr

When a mesh user wants torrent content:

```
Request flow:

  1. User provides info hash (magnet link or torrent file)
     e.g., magnet:?xt=urn:btih:abc123...

  2. Bridge resolves the info hash:
     - Queries Mainline DHT for peers
     - Contacts trackers if specified
     - Downloads metadata via BEP-9 (ut_metadata extension)

  3. Bridge downloads the content:
     - Connects to BitTorrent peers via uTP or TCP
     - Downloads pieces, verifies SHA-1/SHA-256 piece hashes
     - Assembles complete files

  4. Bridge stores content in MHR-Store:
     - Chunks files into 4 KB DataObjects (Mehr's chunk size)
     - Hashes each chunk with Blake3
     - Creates a manifest DataObject linking chunks
     - Stores with configurable replication

  5. Bridge returns Blake3 root hash to the requesting user
     User fetches DataObjects from MHR-Store via normal Mehr protocols

  6. Bridge caches the content — subsequent mesh requests
     are served directly from MHR-Store, no re-download
```

### Content Verification

The bridge performs a **hash translation**: it verifies BitTorrent integrity (SHA-1/SHA-256 piece hashes) during download, then produces Blake3 hashes for Mehr storage. The user trusts the bridge to have performed this translation honestly.

To reduce trust requirements:

- **Multiple bridges**: If two independent bridges produce the same Blake3 root hash for the same info hash, the content is almost certainly correct. Clients can query multiple bridges and compare.
- **Bridge reputation**: Bridges build [reputation](/docs/L2-security/security#reputation) through the standard trust system. A bridge that serves corrupted content loses reputation and trust.
- **Torrent file forwarding**: The bridge can forward the original torrent metadata (piece hashes) to the user. The user can verify individual pieces against the original SHA-1/SHA-256 hashes if they want to cross-check the bridge's Blake3 hashing.

## Content Flow: Mehr → BitTorrent

The bridge can also seed Mehr content into the BitTorrent network:

```
Seeding flow:

  1. Mehr user publishes content to MHR-Store (Blake3-addressed DataObjects)
  2. User requests the bridge to seed the content on BitTorrent
  3. Bridge fetches DataObjects from MHR-Store, reassembles files
  4. Bridge creates a torrent file (computes SHA-1/SHA-256 piece hashes)
  5. Bridge announces to the Mainline DHT and begins seeding
  6. BitTorrent users can now download via magnet link or torrent file
  7. Bridge is paid by the Mehr user for outbound bandwidth via payment channels
```

This makes Mehr content available to the billions of devices running BitTorrent clients, without those clients needing to know anything about Mehr.

## Naming Integration

BitTorrent content can be given human-readable names via [MHR-Name](/docs/L5-services/mhr-name):

```
Name binding:
  my-distro@topic:linux → ContentHash(Blake3 root of Ubuntu ISO fetched via bridge)
  paper-collection@topic:science → ContentHash(Blake3 root of archive fetched via bridge)
```

A user can register a name pointing to the Blake3 hash of content originally sourced from BitTorrent. Other mesh users look up the name and fetch the content from MHR-Store — they never need to know it came from BitTorrent.

For content that updates (e.g., a regularly updated dataset), the bridge can use the torrent's BEP-46 mutable torrent feature: a mutable DHT entry (Ed25519-signed, monotonic sequence number) points to the latest info hash. The bridge maps this to an MHR-Name binding that updates when the mutable torrent updates.

## BEP-44 Alignment

BitTorrent's BEP-44 (arbitrary DHT data storage) uses the same cryptographic primitives as Mehr:

| BEP-44 | Mehr Equivalent |
|--------|----------------|
| Ed25519 public key (32 bytes) | Ed25519 public key (32 bytes) |
| Ed25519 signature (64 bytes) | Ed25519 signature (64 bytes) |
| Monotonic sequence number | Monotonic sequence number (NameBinding, Vouch, etc.) |
| Mutable DHT entry (1 KB max) | IdentityClaim, NameBinding (~122–465 bytes) |
| Immutable DHT entry (keyed by SHA-1 of value) | Immutable DataObject (keyed by Blake3 of content) |

A bridge can translate between BEP-44 mutable entries and Mehr NameBindings or IdentityClaims with minimal impedance. Both systems support the pattern: "signed record, monotonically increasing version, stored in a DHT."

## Economic Model

The bridge is a [capability marketplace](/docs/L4-marketplace/overview) service, discoverable and payable like any other:

| Cost | Who Pays | Mechanism |
|------|---------|-----------|
| BitTorrent download bandwidth | Bridge operator (internet costs) | Recouped from requester's service fee |
| Mesh-side storage (MHR-Store) | Requester | Standard [storage pricing](/docs/L5-services/mhr-store) |
| Mesh-side relay to requester | Requester | Standard [relay payment channels](/docs/L3-economics/payment-channels) |
| Bridge seeding (Mehr → BT) | Content owner | Pays bridge for outbound internet bandwidth |

The bridge advertises `Capability(bittorrent_bridge, ...)` and competes with other bridges on price, speed, and reliability. Popular torrents get cached in MHR-Store and served from the mesh — subsequent requests don't go through the bridge at all.

## Constraints and Limitations

**Internet required**: The bridge must have internet access to reach the BitTorrent network. Mesh-only nodes access BitTorrent content indirectly through the bridge.

**Latency**: Downloading a torrent takes time (seconds to minutes depending on swarm size and content). The bridge uses store-and-forward — the user's request is asynchronous. For popular content already cached in MHR-Store, latency is just mesh relay time.

**Bandwidth mismatch**: BitTorrent assumes broadband; Mehr supports LoRa at 500 bps. Large files (multi-GB) are practical only for mesh nodes on WiFi or better. The bridge can serve partial content (specific files from a multi-file torrent) to reduce bandwidth.

**No E2E encryption with BitTorrent peers**: BitTorrent's MSE/PE is obfuscation, not encryption. The bridge sees the cleartext content. Mesh-side delivery is encrypted end-to-end via Mehr's standard E2E layer — but the bridge itself is a trust boundary for content integrity.

**Legal**: BitTorrent is a neutral protocol used for both legitimate and infringing content. Bridge operators are responsible for compliance with applicable law, just as BitTorrent tracker operators are today. The bridge is a service, not infrastructure — operators choose what to cache and serve.

## Comparison

| | Direct BitTorrent | Via Mehr Bridge |
|---|---|---|
| **Requires internet** | Yes | No (bridge proxies) |
| **Requires IP address** | Yes (for peering) | No (mesh addressing) |
| **Content cached locally** | Only while seeding | Stored in MHR-Store, served from mesh |
| **Payment** | None (volunteer seeding) | MHR micropayments for bridge + relay + storage |
| **Content discovery** | Magnet links, trackers, DHT | MHR-Name + magnet links via bridge |
| **Works on LoRa** | No | Yes (for small files; bridge handles BT-side) |
| **Content integrity** | SHA-1/SHA-256 piece hashes | Bridge verifies BT hashes + Blake3 for Mehr storage |
| **Identity** | None (anonymous peer IDs) | Mehr Ed25519 identity for requesting user |

---

## Development

### Roadmap
<!-- Source: docs/development/roadmap.md -->

# Implementation Roadmap

The Mehr implementation follows a **server-first** strategy: get the protocol running on well-connected Linux servers over traditional internet, prove the core services work, then extend to phones and mesh radio. The protocol spec is comprehensive because it needs to be — but implementation is ruthlessly phased. Each phase delivers something people can use, not just something that passes tests.

```mermaid
graph LR
    P1["<b>Phase 1: Linux Server Node (MVP)</b><br/>TCP/IP transport<br/>Storage + DHT<br/>Trust graph<br/>Free tier only<br/><i>Users: server operators</i>"]
    P2["<b>Phase 2: Economics + Social</b><br/>Payment channels<br/>VRF lottery<br/>CRDT ledger<br/>Social feeds<br/><i>Users: economy bootstraps</i>"]
    P3["<b>Phase 3: Mobile + Mesh</b><br/>Phone apps<br/>LoRa relay nodes<br/>WiFi/BLE mesh<br/>Gateway operators<br/><i>Users: mobile communities</i>"]
    P4["<b>Phase 4: Full Ecosystem</b><br/>Advanced compute<br/>Licensing<br/>Onion routing<br/>Protocol bridges<br/><i>Users: mature ecosystem</i>"]

    P1 --> P2 --> P3 --> P4
```

**Principle**: Start where the resources are. Servers have bandwidth, uptime, storage, and compute. Debug the protocol on reliable hardware over reliable links, then extend to constrained devices and radio. The free tier (trusted peer communication) is a complete product on its own. MHR tokens, economics, and advanced features come only after there are real nodes generating real traffic. Token follows utility, never leads it.

---

## Phase 1: Server Node (MVP)

**Focus**: A Linux daemon that lets servers join a decentralized network, providing compute, storage, and relay services over standard internet connections. The free tier only — no tokens, no payment.

**Why server first**: Servers have public IPs (or easily configured port forwarding), reliable uptime, abundant bandwidth, and real storage and compute resources to offer. TCP/IP transport is trivial compared to radio. This is the fastest path to a working protocol — debug routing, gossip, storage, and DHT on hardware that can actually run them well, without fighting radio propagation, phone OS restrictions, or constrained-device limitations. The `no_std` constraint for ESP32 can be added later; starting with the full Rust standard library makes development significantly faster.

### Milestone 1.1: Core Protocol Library (Rust)

- `NodeIdentity` (Ed25519 keypair generation, destination hash derivation, X25519 conversion)
- Link-layer encryption (X25519 ECDH + ChaCha20-Poly1305, counter-based nonces, key rotation)
- Packet framing (Reticulum-compatible: header, addresses, context, data)
- TCP transport interface (outbound connections, bidirectional links, keepalive)
- Announce generation and forwarding with Ed25519 signature verification

**Acceptance**: Two Linux nodes establish an encrypted link over TCP, exchange announces, and forward packets. Unauthenticated nodes are rejected.

### Milestone 1.2: Bootstrap + Peer Discovery

- DNS-based genesis gateway discovery (well-known domain resolves to genesis gateway IPs — primary bootstrap method)
- Hardcoded bootstrap node list as fallback (known IP:port pairs, including genesis gateway addresses)
- Peer exchange protocol (connected peers share their known peer lists)
- Outbound-only NAT traversal (nodes behind NAT connect outbound to bootstrap nodes; TCP connection is bidirectional once established)
- Peer persistence (remember previously connected peers across restarts)

**Acceptance**: A new node discovers the genesis gateway via DNS and connects to the network within 30 seconds. After 3 gossip rounds, the node has discovered peers beyond the genesis gateway. Fallback to hardcoded list works when DNS is unavailable. A node behind NAT connects outbound and participates fully as a relay. Restarting a node reconnects to previously known peers without hitting the bootstrap list.

### Milestone 1.3: Routing + Gossip

- `CompactPathCost` (7-byte encoding/decoding, log-scale math, relay update logic including `bottleneck_mtu`)
- Routing table (`RoutingEntry` with cost, latency, bandwidth, hop count, bottleneck MTU, reliability)
- Greedy forwarding with `PathPolicy` scoring (Cheapest, Fastest, Balanced, LargestMTU)
- Gossip protocol (60-second rounds, bloom filter state summaries, delta exchange)
- Bandwidth budget enforcement (4-tier allocation)
- Announce propagation rules (event-driven + 30-min refresh, hop limit, expiry, link failure detection)
- Per-link MTU negotiation (`LinkCapabilities` exchange during link establishment)
- Route probing (`ProbeRequest`/`ProbeResponse`, opt-in, rate-limited)

**Acceptance**: A 10-node network converges routing tables within 3 gossip rounds. Packets are forwarded via cost-optimal paths. Removing a node causes re-routing within 3 minutes. Gossip overhead stays within 10% budget. Path MTU is correctly reported via `bottleneck_mtu` and packets are sized appropriately per path. Route probes return accurate RTT and MTU measurements.

### Milestone 1.4: Trust Graph + Free Relay

- `TrustConfig` implementation (trusted peers, cost overrides, scopes)
- Free relay logic (sender trusted AND destination trusted → no lottery, no channels)
- Adding/removing trusted peers

**Acceptance**: Trusted peers relay traffic for free with zero economic overhead. The full relay stack works with zero tokens in circulation.

### Milestone 1.5: MHR-Store

- `DataObject` types (Immutable, Mutable, Ephemeral)
- Storage agreements (bilateral, free between trusted peers initially)
- Proof of storage (Blake3 Merkle challenge-response)
- Erasure coding (Reed-Solomon, default schemes by size)
- Repair protocol (detect failure → assess → reconstruct → re-store)
- Garbage collection (7-tier priority)
- Chunking (4 KB chunks, parallel retrieval, resumable transfers)

**Acceptance**: A node stores a DataObject with replication factor 3 across the network. Proof-of-storage challenges pass. Erasure coding reconstructs from k of n chunks. Chunked transfer resumes after interruption.

### Milestone 1.6: MHR-DHT + MHR-Pub

- DHT routing (XOR distance + cost weighting, α=0.7)
- k=3 replication with cost-bounded storage set
- Lookup and publication protocols
- Subscription types (Key, Prefix, Node, Scope)
- Delivery modes (Push, Digest, PullHint)
- Bandwidth-adaptive mode selection

**Acceptance**: A node publishes a DataObject and it's discoverable via DHT lookup from any node in the network. MHR-Pub delivers notifications to subscribers within 2 gossip rounds.

### Milestone 1.7: Linux Daemon + CLI

- `mehrd` daemon (background process, systemd service file)
- Configuration file (bootstrap peers, listen address, storage path, trust config)
- CLI tool (`mehr`) for node management:
  - `mehr status` — node identity, connected peers, routing table summary
  - `mehr peers` — list connected peers with link quality metrics
  - `mehr trust add/remove <destination_hash>` — manage trusted peers
  - `mehr store put/get <file>` — store and retrieve data objects
  - `mehr dht lookup <key>` — query the DHT
- Logging and metrics (structured logs, Prometheus-compatible metrics endpoint)

**Acceptance**: A sysadmin can install the daemon, configure bootstrap peers, and join the network. The CLI provides full visibility into node state. The daemon runs unattended and recovers from restarts.

### Phase 1 Deliverable

**A network of Linux servers providing decentralized storage and relay.** Install the daemon, configure a few bootstrap peers, and your server joins the network — contributing storage, relay bandwidth, and DHT capacity. Trust your friends' servers for free relay. This is the foundation everything else builds on.

**Target audiences**: homelabbers, self-hosting enthusiasts, VPS operators, privacy-conscious sysadmins, distributed systems developers.

---

## Phase 2: Economic Layer + Social

**Focus**: MHR token genesis, payment infrastructure, and social features. With real servers generating real traffic and providing real storage, economics can be validated against actual usage patterns.

### Milestone 2.1: Payment Channels

- VRF lottery implementation (ECVRF-ED25519-SHA512-TAI per RFC 9381)
- Adaptive difficulty (local per-link, formula: `win_prob = target_updates / observed_packets`)
- `ChannelState` (200 bytes, dual-signed, sequence-numbered)
- Channel lifecycle (open, update on win, settle, dispute with 2,880-round window, abandon after 4 epochs)
- `SettlementRecord` generation and dual-signature

**Acceptance**: Two nodes relay 1,000 packets. The relay wins the VRF lottery approximately `1000 × win_probability` times (within 2σ). Channel updates occur only on wins. Settlement produces a valid dual-signed record. Dispute resolution correctly rejects old states.

### Milestone 2.2: CRDT Ledger + Epoch Compaction

- `AccountState` (GCounter for earned/spent, GSet for settlements)
- GCounter merge (pointwise max per-node entries)
- GCounter rebase at epoch compaction (prevents overflow from money velocity)
- Settlement flow (validation: 2 sig checks + Blake3 hash + GSet dedup, gossip forward)
- Balance derivation (`earned - spent`, reject negative)
- Epoch trigger logic (3-trigger: settlement count, GSet size, small-partition adaptive)
- Epoch lifecycle (Propose → Acknowledge at 67% → Activate → Verify → Finalize)
- Merkle-tree snapshot (full tree — servers have the memory for it)
- `BalanceProof` generation and verification

**Acceptance**: A 20-node network triggers epochs correctly. Balances converge across the network. GCounter rebase keeps counters bounded.

### Milestone 2.3: Token Genesis + Demand-Backed Mining

- Emission schedule implementation (10^12 μMHR/epoch, halving every 100,000 epochs, shift clamp at 63)
- Tail emission floor (0.1% of circulating supply annually)
- Genesis allocation to genesis gateway operator (transparent, visible in ledger from epoch 0)
- Demand-backed minting eligibility (VRF wins count only on funded-channel traffic)
- Revenue-capped minting (`effective_minting = min(emission_schedule, 0.5 × total_channel_debits)`)
- `RelayWinSummary` aggregation per epoch (demand-backed wins only)
- Mint distribution proportional to verified VRF lottery wins
- Channel-funded relay payments (coexist with minting)

**Acceptance**: The first epoch mints MHR and distributes it to relay nodes. Genesis allocation is visible in the ledger. Distribution is proportional to demand-backed wins. Minting on unfunded-channel traffic is rejected. Revenue cap limits minting to 50% of channel debits. Minting and channel payments coexist. Token supply follows the emission schedule.

### Milestone 2.4: Reputation + Credit

- `PeerReputation` scoring (relay, storage, compute scores 0-10000)
- Score update formulas (success: diminishing gains, failure: 10% penalty)
- Trust-weighted referrals (1-hop, capped at 50%)
- Transitive credit (direct: full, friend-of-friend: 10%, 3+ hops: none)
- `CreditState` tracking per grantee
- Credit rate limiting per trust distance and per epoch

**Acceptance**: Reliable nodes build reputation. Credit extends through trust graph. A friend-of-friend gets exactly 10% of the direct credit line. Default handling absorbs debt correctly.

### Milestone 2.5: Paid Storage + Kickback

- StorageAgreement with payment channel integration (pay-per-duration)
- Kickback fields (revenue sharing between storage node and content author)
- Self-funding content detection (kickback exceeds storage cost)
- Content propagation through scope hierarchy

**Acceptance**: Storage nodes earn for hosting data. Kickback flows correctly on retrieval. Self-funding content persists without author payment.

### Milestone 2.6: Social Layer

- `PostEnvelope` (free layer) + `SocialPost` (paid layer) — mutable DataObjects
- `UserProfile` (display name, bio, avatar, scopes, claims)
- Hierarchical scopes (Geo + Topic) with scope matching
- Five feed types: follow, geographic, interest, intersection, curated
- `CuratedFeed` with curator kickback
- Publishing flow (post_id generation, envelope propagation)
- Editing (mutable DataObject semantics, sequence versioning)
- Replies, boosts, references
- MHR-Name (scope-based naming, conflict resolution, petnames)

**Acceptance**: A user publishes a post tagged with geographic and interest scopes. The post's envelope appears in subscribers' feeds. Readers pay to fetch full content. Kickback flows to author. Curated feeds work end-to-end.

### Milestone 2.7: MHR-Compute

- 47-opcode MHR-Byte interpreter implementation in Rust
- Cycle cost enforcement
- Resource limit enforcement (max_memory, max_cycles, max_state_size)
- WASM execution environment (Wasmtime, Light + Full tiers)
- Compute delegation via capability marketplace
- Reference test vector suite for cross-platform conformance

**Acceptance**: A compute contract executes on a server node. MHR-Byte and WASM produce identical results for the same inputs. Compute delegation routes requests to capable nodes. Cycle cost metering terminates runaway contracts.

### Milestone 2.8: Test Network

- Deploy a 20-50 node test network across multiple server operators
- Instrument for: routing convergence, gossip bandwidth, storage reliability, economic dynamics, social UX
- Run for at least 8 weeks
- Document: failure modes, parameter tuning, real-world performance, economic balance

**Acceptance**: Test network operates continuously for 8 weeks. Storage proofs pass reliably. Token economy reaches equilibrium. Published test report with metrics.

### Phase 2 Deliverable

**A functioning decentralized economy on Linux servers.** MHR tokens enter circulation through proof-of-service. Server operators earn by relaying traffic and hosting storage. Content creators earn through kickback. Compute delegation works. The economic layer is live, validated on real servers with real traffic.

---

## Phase 3: Mobile + Mesh

**Focus**: Bring the proven protocol to phones and mesh radio. The protocol is already battle-tested on servers — now extend it to constrained devices and transport-independent operation.

### Milestone 3.1: `no_std` Core Library

- Factor the core protocol library into `no_std`-compatible crate
- Separate transport-specific code (TCP) from protocol logic
- Verify all crypto operations work without `std` (Ed25519, X25519, ChaCha20, Blake3)
- Sparse Merkle-tree snapshots for constrained devices (under 5 KB)

**Acceptance**: The core protocol library compiles for `no_std` targets. All protocol-level tests pass on both `std` and `no_std` builds.

### Milestone 3.2: Phone Apps

- Android app (Kotlin/Rust FFI) — Android first for broader device support and sideloading
- iOS app (Swift/Rust FFI) — follows Android
- Contact management (add trusted peers via QR code, NFC, or manual key entry)
- Messaging UI (conversations, groups, media sending adapted to link quality)
- E2E encrypted messaging (store-and-forward, offline delivery)
- Group messaging with co-admin delegation
- Voice on WiFi links (Opus codec)
- Connect to server network over internet (phone as a light client)
- WiFi Direct and BLE transport for local phone-to-phone mesh
- Background mesh relay (phone relays traffic while in pocket)
- Multi-transport handoff (internet ↔ WiFi Direct ↔ BLE, seamless)

**Acceptance**: A non-technical user can install the app, add a friend via QR code, and exchange messages. The app connects to the server network over internet for relay and storage. Phone-to-phone WiFi Direct messaging works without internet. Voice calls work on WiFi links.

### Milestone 3.3: LoRa Transport

- LoRa interface implementation (SX1276/SX1262 via `no_std` Rust)
- Off-the-shelf hardware support:
  - Heltec WiFi LoRa 32 (~$15)
  - LILYGO T-Beam (~$25, with GPS)
  - RAK WisBlock (~$30, modular)
  - RNode (Reticulum-native)
- LTE-M and NB-IoT interface support (carrier-managed LPWAN)
- Multi-interface bridging (phone WiFi ↔ LoRa relay ↔ WiFi ↔ server network)
- Solar relay firmware (ESP32 L1: transport, routing, gossip — runs on $30 solar kit)
- Congestion control tuning for constrained links (CSMA/CA, backpressure)

**Acceptance**: A LoRa relay extends the network to areas without internet. A phone sends a message that hops: phone → WiFi → LoRa relay → WiFi → server → destination. Solar relay runs unattended for 30+ days.

### Milestone 3.4: Gateway Operators

- Gateway trust-based onboarding (add consumer to trusted_peers, extend credit)
- Fiat billing integration (subscription, prepaid, pay-as-you-go — gateway's choice)
- Cloud storage via gateway (consumer stores files, gateway handles MHR)
- Gateway-provided connectivity (ethernet ports, WiFi access points)

The [genesis service gateway](/docs/L3-economics/token-economics#genesis-service-gateway) is the first instance of this pattern — it bootstraps the economy in Phase 2. This milestone generalizes gateway mechanics for any operator to deploy.

**Acceptance**: A consumer signs up with a gateway, pays fiat, and uses the network without seeing MHR. Traffic flows through gateway trust. Consumer can switch gateways without losing identity.

### Milestone 3.5: Mesh Test Networks

- Deploy 3-5 physical test networks (urban, rural, campus, event)
- Each network: 10-50 nodes (phones + LoRa relays + server backbone) across at least 2 transports
- Instrument for: routing convergence, gossip bandwidth, storage reliability, mesh UX
- Run for at least 4 weeks per network
- Document: failure modes, parameter tuning, real-world performance

**Acceptance**: Test networks operate continuously for 4 weeks. Users report messaging and mesh features work reliably. Published test report with metrics.

### Phase 3 Deliverable

**The full network: servers as backbone, phones as endpoints, mesh radio for off-grid.** Phone users get encrypted messaging and social feeds backed by the server network's storage and compute. LoRa relays extend coverage to areas without internet. Gateway operators bridge fiat consumers to the mesh economy. The same protocol runs from $30 ESP32 to datacenter servers.

---

## Phase 4: Full Ecosystem

**Focus**: Advanced capabilities, application richness, and ecosystem growth.

### Milestone 4.1: Identity + Governance

- Identity claims and vouches (GeoPresence, CommunityMember, KeyRotation, Capability, ExternalIdentity)
- RadioRangeProof (geographic verification via LoRa beacons)
- Peer attestation and transitive confidence
- Vouch lifecycle (create, gossip, verify, renew, revoke)
- Voting prerequisites (geographic eligibility from verified claims)

### Milestone 4.2: Rich Applications

- Voice (Codec2 on LoRa, Opus on WiFi, bandwidth bridging, seamless handoff)
- Digital licensing (LicenseOffer, LicenseGrant, verification chain, off-network verifiability)
- Cloud storage (client-side encryption, erasure coding, sync between devices, file sharing)
- Forums (append-only logs, moderation contracts)
- Marketplace (listings, escrow contracts)

### Milestone 4.3: Interoperability + Privacy

- Third-party protocol bridges (SSB, Matrix, Briar) — [standalone gateway services](design-decisions#protocol-bridges-standalone-gateway-services) with identity attestation
- Onion routing implementation (`PathPolicy.ONION_ROUTE`, per-packet layered encryption)
- Private compute tiers (Split Inference, Secret Sharing, TEE)

### Milestone 4.4: Ecosystem Growth

- Developer SDK and documentation
- Community-driven capability development
- Hardware partnerships and reference design refinement (informed by real deployment data)
- Custom hardware (only if demand justifies — let usage data guide form factors)

### Phase 4 Deliverable

A full-featured decentralized platform with rich applications, privacy-enhanced routing, identity governance, and interoperability with existing protocols.

---

## Implementation Language

The primary implementation language is **Rust**, chosen for:

- Memory safety without garbage collection (critical for embedded targets)
- `no_std` support for ESP32 firmware (added in Phase 3)
- Strong ecosystem for cryptography and networking
- Single codebase from microcontroller to server
- FFI to Kotlin (Android) and Swift (iOS) for phone apps

Phase 1-2 use the full standard library. The `no_std` factoring happens at the start of Phase 3 when embedded targets are introduced.

## Platform Targets

| Platform | Implementation | Phase |
|----------|---------------|-------|
| Linux server / desktop | Rust native daemon + CLI (full node) | Phase 1 |
| Raspberry Pi / Linux SBC | Rust native (bridge, gateway, storage) | Phase 1-2 |
| Android phone | Rust core + Kotlin UI via FFI | Phase 3 |
| iOS phone | Rust core + Swift UI via FFI | Phase 3 |
| ESP32 + LoRa | Rust `no_std` (L1 relay) | Phase 3 |

All implementations speak the same wire protocol and interoperate on the same network.

## Bootstrap Strategy

New nodes discover the network through a layered bootstrap mechanism:

1. **Hardcoded bootstrap list**: The daemon ships with a list of known bootstrap node IP:port pairs. These are well-connected, high-uptime servers operated by early network participants.
2. **DNS bootstrap**: A well-known domain resolves to current bootstrap node IPs. This allows updating the bootstrap list without software releases.
3. **Peer exchange**: Once connected to any node, the gossip protocol discovers the rest of the network. Connected peers share their known peer lists.
4. **Peer persistence**: Previously connected peers are remembered across restarts, so a node that has been online before rarely needs the bootstrap list.

The bootstrap list is a starting point, not a dependency. After initial connection, the announce mechanism and gossip protocol handle all peer discovery. Bootstrap nodes have no special protocol role — they are ordinary nodes that happen to be well-known.

## NAT Traversal

Most servers targeted in Phase 1 have public IPs or easily configured port forwarding. For nodes behind NAT:

- **Outbound TCP connections** traverse NAT automatically. A node behind NAT connects outbound to a known peer; the TCP connection is bidirectional once established. This covers the vast majority of home server setups.
- **Relay forwarding**: A node that cannot accept inbound connections is still reachable — traffic routes through peers that have direct links to it. This is standard Mehr relay operation.
- **UPnP/NAT-PMP** (optional): Automatic port forwarding on consumer routers, attempted on startup.
- **UDP hole punching** (Phase 3+): For phone-to-phone mesh scenarios where both parties are behind NAT.

No STUN/TURN servers are required. The Mehr relay mechanism itself provides the relay function that TURN would otherwise fill.

## Test Network Strategy

Real distributed test networks, not simulations:

- Phase 1 test networks are server-only (TCP/IP over internet)
- Phase 2 test networks enable economics and measure token dynamics on real traffic
- Phase 3 test networks add phones and LoRa relays, validating the full transport range
- Each test network should represent a different deployment scenario
- Test networks validate both the protocol and the user experience

## Why This Order

The previous roadmap (phone-mesh-first) would require solving radio transport, constrained-device limitations, phone OS restrictions, and `no_std` compatibility before any protocol logic could be tested. This roadmap gets the protocol running first on hardware where development is fast, then extends to harder targets:

| Phase | What Users Get | What the Network Gets |
|-------|---------------|---------------------|
| 1 | Decentralized storage + relay on Linux servers | Real nodes, real traffic, battle-tested protocol |
| 2 | Token economy, social feeds, compute | Real economic data, real market pricing |
| 3 | Phone apps, mesh radio, off-grid operation | Mobile users, mesh coverage, transport diversity |
| 4 | Rich apps, privacy, interoperability | Mature ecosystem |

Each phase is viable on its own. Phase 1 is a useful product even if phones never ship — a decentralized storage and relay network for server operators. Phase 2 adds a functioning economy. Phase 3 extends to mobile and mesh. No phase depends on token speculation or hardware manufacturing for its value.

**Key advantage**: By the time Phase 3 tackles constrained devices and radio, the protocol is already proven. Bugs in routing, gossip, storage, DHT, and economics have been found and fixed on servers where debugging is easy. The `no_std` factoring is a well-scoped engineering task applied to known-good code, not a simultaneous protocol design and embedded engineering challenge.

## Implementability Assessment

Phase 1 is **fully implementable** with the current specification. All protocol-level gaps have been resolved:

| Component | Spec Status | Key References |
|-----------|------------|----------------|
| Identity + Encryption | Complete | [Security](/docs/L2-security/security) |
| Packet format + CompactPathCost | Complete (wire format specified) | [Network Protocol](/docs/L1-network/network-protocol#mehr-extension-compact-path-cost) |
| Routing + Announce propagation | Complete (scoring, announce rules, expiry, failure detection) | [Network Protocol](/docs/L1-network/network-protocol#routing) |
| Gossip protocol | Complete (bloom filter, bandwidth budget, 4-tier) | [Network Protocol](/docs/L1-network/network-protocol#gossip-protocol) |
| Congestion control | Complete (3-layer, priority levels, backpressure) | [Network Protocol](/docs/L1-network/network-protocol#congestion-control) |
| Trust neighborhoods | Complete (free relay, credit, scopes) | [Trust & Neighborhoods](/docs/L3-economics/trust-neighborhoods) |
| MHR-Store | Complete (agreements, proofs, erasure coding, repair) | [MHR-Store](/docs/L5-services/mhr-store) |
| MHR-DHT + MHR-Pub | Complete (routing, replication, subscriptions) | [MHR-DHT](/docs/L5-services/mhr-dht), [MHR-Pub](/docs/L5-services/mhr-pub) |
| VRF lottery + Payment channels | Complete (RFC 9381, difficulty formula, channel lifecycle) | [Payment Channels](/docs/L3-economics/payment-channels) |
| CRDT ledger + Settlement | Complete (validation rules, GCounter merge, GSet dedup, rebase) | [CRDT Ledger](/docs/L3-economics/crdt-ledger) |

---

### Design Decisions
<!-- Source: docs/development/design-decisions.md -->

# Design Decisions Log

This page documents the key architectural decisions made during Mehr protocol design, including alternatives considered and the rationale for each choice.

## Network Stack: Reticulum as Initial Transport

| | |
|---|---|
| **Chosen** | Use [Reticulum Network Stack](https://reticulum.network/) as the design reference for transport; treat the transport layer as a [swappable interface](#transport-layer-swappable-implementation) |
| **Alternatives** | Clean-room implementation from day one, libp2p, custom protocol |
| **Rationale** | Reticulum solves transport abstraction, cryptographic identity, mandatory encryption, sender anonymity (no source address), and announce-based routing — all proven on LoRa at 5 bps. Mehr's transport interface is informed by Reticulum's design and extends it with CompactPathCost annotations and economic primitives. The transport layer is an interface: Mehr defines what it needs, and any conforming implementation can be used without affecting layers above. |

## Routing: Kleinberg Small-World with Cost Weighting

| | |
|---|---|
| **Chosen** | Greedy forwarding on a Kleinberg small-world graph with cost-weighted scoring |
| **Alternatives** | Pure Reticulum announce model, Kademlia, BGP-style routing, Freenet-style location swapping |
| **Rationale** | The physical mesh naturally forms a small-world graph: short-range radio links serve as lattice edges, backbone/gateway links serve as Kleinberg long-range contacts. Greedy forwarding achieves O(log² N) expected hops — a formal scalability guarantee. Cost weighting trades path length for economic efficiency. Unlike Freenet, no location swapping is needed because destination hashes are self-assigned and Reticulum announcements build the navigable topology. |

## Payment: Stochastic Relay Rewards

| | |
|---|---|
| **Chosen** | Probabilistic micropayments via VRF-based lottery (channel update only on wins) |
| **Alternatives** | Per-packet accounting, per-minute batched accounting, subscription-based, random-nonce lottery |
| **Rationale** | Per-packet and batched payment require frequent channel state updates, consuming ~2-4% bandwidth on LoRa links. Stochastic rewards achieve the same expected income but trigger updates only on lottery wins — reducing economic overhead by ~10x. Adaptive difficulty ensures fairness across traffic levels. The law of large numbers guarantees convergence for active relays. **The lottery uses a VRF (ECVRF-ED25519-SHA512-TAI, RFC 9381)** rather than a random nonce to prevent relay nodes from grinding nonces to win every packet. The VRF produces exactly one verifiable output per (relay key, packet) pair, reusing the existing Ed25519 keypair. |

## Settlement: CRDT Ledger

| | |
|---|---|
| **Chosen** | CRDT ledger (GCounters + GSet) |
| **Alternatives** | Blockchain, federated sidechain |
| **Rationale** | Partition tolerance is non-negotiable. CRDTs converge without consensus. A blockchain requires global ordering, which is impossible when network partitions are expected operating conditions. **Tradeoff**: double-spend prevention is probabilistic, not perfect. Mitigated by channel deposits, credit limits, reputation staking, and blacklisting — making cheating economically irrational for micropayments. |

## Communities: Emergent Trust Neighborhoods

| | |
|---|---|
| **Chosen** | Trust graph with emergent neighborhoods (no explicit zones) |
| **Alternatives** | Explicit zones with admin keys and admission policies |
| **Rationale** | Explicit zones require someone to create and manage them — centralized thinking in decentralized clothing. They impose UX burden and artificially fragment communities. Trust neighborhoods emerge naturally from who you trust: free communication between trusted peers, paid between strangers. No admin, no governance, no admission policies. Communities form the same way they form in real life — through relationships, not administrative acts. The trust graph provides Sybil resistance economically (vouching peers absorb debts). |

## Compaction: Epoch Checkpoints with Bloom Filters

| | |
|---|---|
| **Chosen** | Epoch checkpoints with bloom filters |
| **Alternatives** | Per-settlement garbage collection, TTL-based expiry |
| **Rationale** | The settlement GSet grows without bound. Bloom filters at 0.01% FPR compress 1M settlement hashes from ~32 MB to ~2.4 MB. A settlement verification window during the grace period recovers any settlements lost to false positives. Epochs are triggered by settlement count (~10,000 batches), not wall-clock time, for partition tolerance. |

## Compute Contracts: MHR-Byte

| | |
|---|---|
| **Chosen** | MHR-Byte (minimal bytecode, ~50 KB interpreter) |
| **Alternatives** | Full WASM everywhere |
| **Rationale** | ESP32 microcontrollers can't run a WASM runtime. MHR-Byte provides basic contract execution on even the most constrained devices. WASM is offered as an optional capability on nodes with sufficient resources. |

## Encryption: Ed25519 + X25519

| | |
|---|---|
| **Chosen** | Ed25519 for identity/signing, X25519 for key exchange (Reticulum-compatible) |
| **Alternatives** | RSA, symmetric-only |
| **Rationale** | Ed25519 has 32-byte public keys (compact for radio), fast signing/verification, and is widely proven. X25519 provides efficient Diffie-Hellman key exchange. Compatible with Reticulum's crypto model. RSA keys are too large for constrained links. |

## Source Privacy: No Source Address (Default)

| | |
|---|---|
| **Chosen** | No source address in packet headers (inherited from Reticulum) as the default; [opt-in onion routing](#onion-routing-per-packet-layered-encryption-opt-in) for high-threat environments |
| **Alternatives** | Mandatory onion routing for all traffic |
| **Rationale** | Onion routing adds 21% payload overhead on LoRa — unacceptable as a default for all traffic. Omitting the source address is free and effective against casual observation. Per-packet layered encryption is available opt-in via `PathPolicy.ONION_ROUTE` for users who need stronger traffic analysis resistance. |

## Naming: Scope-Based, No Global Namespace

| | |
|---|---|
| **Chosen** | Hierarchical-scope-based names (e.g., `alice@geo:us/oregon/portland`) |
| **Alternatives** | Global names via consensus, flat community labels (`alice@portland-mesh`) |
| **Rationale** | Global consensus contradicts partition tolerance. Flat community labels were replaced by [hierarchical scopes](/docs/L3-economics/trust-neighborhoods#hierarchical-scopes) — geographic (`Geo`) and interest (`Topic`) — which provide structured resolution. Names resolve against scope hierarchy: `alice@geo:portland` queries Portland scope first, then broadens. Two different cities named "portland" are disambiguated by longer paths (`alice@geo:us/oregon/portland` vs `alice@geo:us/maine/portland`). Proximity-based resolution handles most cases naturally. Local petnames provide a fallback. |

## Cost Annotations: Compact Path Cost (No Per-Relay Signatures)

| | |
|---|---|
| **Chosen** | 7-byte constant-size `CompactPathCost` (running totals updated by each relay, no per-relay signatures) |
| **Alternatives** | Per-relay signed CostAnnotation (~84 bytes per hop), aggregate signatures, signature-free with Merkle proof |
| **Rationale** | Per-relay signatures make announces grow linearly with path length — 84 bytes × N hops. On a 1 kbps LoRa link with 3% routing budget, this limits convergence to ~1 announce per 22+ seconds. CompactPathCost uses 7 bytes total regardless of path length: log-encoded cumulative cost, worst-case latency, bottleneck bandwidth, hop count, and bottleneck MTU. Per-relay signatures are unnecessary because routing decisions are local (you trust your link-authenticated neighbor), trust is transitive at each hop, and the market enforces honesty (overpriced relays get routed around, underpriced relays lose money). The announce itself remains signed by the destination node. |

## Congestion Control: Three-Layer Design

| | |
|---|---|
| **Chosen** | Link-level CSMA/CA + per-neighbor token bucket + 4-level priority queuing + economic cost response |
| **Alternatives** | Pure CSMA/CA only, rigid TDMA, end-to-end TCP-style congestion control |
| **Rationale** | A single mechanism is insufficient across the bandwidth range (500 bps to 10 Gbps). CSMA/CA handles collision avoidance on half-duplex radio. Token buckets enforce fair sharing across neighbors. Priority queuing ensures real-time traffic (voice) isn't starved by bulk transfers. Economic cost response (quadratic cost increase under congestion) signals scarcity through the existing cost routing mechanism, causing natural traffic rerouting without new protocol extensions. End-to-end congestion control (TCP-style) is wrong for a mesh — the bottleneck is typically a single constrained link, and hop-by-hop control responds faster. Rigid TDMA wastes bandwidth when some slots are unused. |

## Transport Layer: Swappable Implementation

| | |
|---|---|
| **Chosen** | Define transport as an interface with requirements; use Reticulum as the reference design |
| **Alternatives** | Hard dependency on Reticulum, clean-room from day one |
| **Rationale** | Reticulum provides a proven transport design tested at 5 bps on LoRa, informing the Mehr transport interface. But coupling Mehr to Reticulum's codebase or community roadmap creates fragility. Instead, Mehr defines the transport interface it needs (transport-agnostic links, announce-based routing, mandatory encryption, sender anonymity, per-link MTU negotiation) and uses Reticulum's design as a reference. Mehr extensions are carried as opaque payload in the announce DATA field — a clean separation. Three participation levels (L0 transport-only, L1 Mehr relay, L2 full Mehr) ensure interoperability with any conforming transport. A conforming implementation must meet the full [Transport Interface Specification](/docs/L0-physical/physical-transport#transport-interface-specification), including variable frame sizes — requirements that go beyond Reticulum's fixed 500-byte frame limit. |

## Storage: Pay-Per-Duration with Erasure Coding

| | |
|---|---|
| **Chosen** | Bilateral storage agreements, pay-per-duration, Reed-Solomon erasure coding, lightweight challenge-response proofs |
| **Alternatives** | Filecoin-style PoRep/PoSt with on-chain proofs; Arweave-style one-time-payment permanent storage; simple full replication |
| **Rationale** | Filecoin's Proof of Replication requires GPU-level computation (minutes to seal a sector) — impossible on ESP32 or Raspberry Pi. Arweave's permanent storage requires a blockchain endowment model and assumes perpetually declining storage costs. Both require global consensus. Mehr uses simple Blake3 challenge-response proofs (verifiable in under 10ms on ESP32) and bilateral agreements settled via payment channels. Erasure coding (Reed-Solomon) provides the same durability as 3x replication at 1.5x storage overhead. The tradeoff: we can't prove a node stores data *uniquely* (no PoRep), but we can prove it stores data *at all* — and the data owner doesn't care how the node organizes its disk. |

## Mobile Handoff: Presence Beacons + Credit-Based Fast Start

| | |
|---|---|
| **Chosen** | Transport-agnostic presence beacons, credit-based fast start, roaming cache with channel preservation |
| **Alternatives** | Pre-negotiated handoff (cellular-style), pure re-discovery from scratch, always-connected overlay |
| **Rationale** | Cellular handoff requires a central controller — incompatible with decentralized mesh. Pure re-discovery works but is slow for latency-sensitive sessions. Presence beacons (20 bytes, broadcast every 10 seconds on any interface) let mobile nodes passively discover local relays before connecting. Credit-based fast start allows immediate relay if the mobile node has visible CRDT balance, while the payment channel opens in the background. The roaming cache preserves channels for previously visited areas, enabling zero-latency reconnection on return. No explicit teardown needed — old agreements expire via `valid_until`. |

## Light Client Trust: Content Verification + Multi-Source Queries

| | |
|---|---|
| **Chosen** | Three-tier verification: content-hash check (Tier 1), owner-signature check (Tier 2), multi-source queries (Tier 3) |
| **Alternatives** | Merkle proofs over DHT state, SPV-style state root verification, full DHT replication on clients |
| **Rationale** | Merkle proofs require a global state root, which contradicts partition tolerance (no consensus). SPV-style verification has the same problem. Full DHT replication is too bandwidth-heavy for phones. Instead, content addressing (Tier 1) gives zero-overhead verification for the most common case — `Blake3(data) == key` proves authenticity regardless of relay honesty. Signed objects (Tier 2) prevent forgery of mutable data. Multi-source queries (Tier 3, N=2-3 independent nodes) detect censorship and staleness. Trusted relays skip to single-source for all tiers. Overhead is minimal: at most one extra 192-byte query for critical lookups via untrusted relays. |

## Epoch Triggers: Adaptive Multi-Criteria

| | |
|---|---|
| **Chosen** | Three-trigger system: settlement count ≥ 10,000 (large mesh), GSet size ≥ 500 KB (memory pressure), or partition-proportional threshold with gossip-round floor (small partitions) |
| **Alternatives** | Fixed 10,000-settlement-only trigger, wall-clock timer, per-node independent compaction |
| **Rationale** | A 20-node village on LoRa with low traffic might take months to reach 10,000 settlements. ESP32 nodes (520 KB usable RAM) would exhaust memory first. The adaptive trigger fires at max(200, active_set × 10) settlements with a 1,000-gossip-round floor (~17 hours), keeping GSet under ~6.4 KB for small partitions. The 500 KB GSet size trigger is a safety net regardless of partition size. Proposer eligibility adapts too — only 3 direct links needed (not 10) in small partitions. Wall-clock timers were rejected because they require clock synchronization. Per-node compaction was rejected because it fragments global state. |

## Ledger Scaling: Merkle-Tree Snapshots with Sparse Views

| | |
|---|---|
| **Chosen** | Merkle-tree account snapshot; full tree on backbone nodes, sparse view + Merkle root on constrained devices, on-demand balance proofs (~640 bytes) |
| **Alternatives** | Flat snapshot everywhere, sharded epochs, neighborhood-only ledgers |
| **Rationale** | At 1M nodes the flat snapshot is ~32 MB — unworkable on ESP32 or phones. Sharded epochs fragment the ledger and complicate cross-shard verification. Neighborhood-only ledgers lose global balance consistency. A Merkle tree over the sorted account snapshot gives the best of both: backbone nodes store the full tree (32 MB, feasible on SSD), constrained devices store only their own balance + channel partners + trust neighbors (~1.6 KB for 50 accounts) plus the Merkle root. Any balance can be verified on demand with a ~640-byte proof (20 tree levels × 32 bytes). No global state transfer needed. |

## Transforms/Inference: Compute Capability, Not Protocol Primitive

| | |
|---|---|
| **Chosen** | STT/TTS/inference as compute capabilities in the marketplace |
| **Alternatives** | Dedicated transform layer |
| **Rationale** | Speech-to-text, translation, and other transforms are just compute. Making them protocol primitives over-engineers the foundation. The capability marketplace already handles discovery, negotiation, execution, verification, and payment for arbitrary compute functions. Compute execution is opaque — the protocol does not verify the compute method, only the input/output. Verification strategies (reputation, redundant execution, spot-checking) are consumer-side choices, not protocol enforcement. |

## Group Admin: Delegated Co-Admin (No Threshold Signatures)

| | |
|---|---|
| **Chosen** | Delegated co-admin model: group creator signs delegation certificates for up to 3 co-admins; any co-admin can independently rotate keys and manage members |
| **Alternatives** | Threshold signatures (e.g., 2-of-3 Schnorr multisig), single admin only, leaderless consensus |
| **Rationale** | Threshold signatures (Schnorr multisig, FROST) require multi-round key generation and signing protocols that are too expensive for ESP32 and too complex for LoRa latency. Leaderless consensus contradicts the "no global coordination" principle. Instead, the group creator signs `CoAdminCertificate` records (admin public key + permissions + sequence number, ~128 bytes each) that authorize up to 3 co-admins. Any co-admin can independently add/remove members, rotate the group symmetric key, and promote/demote other co-admins (if authorized). Operations are sequence-numbered; conflicts are resolved by highest sequence number, ties broken by lowest admin public key hash. Overhead is one Ed25519 signature per admin action — no new cryptographic primitives needed. If all admins go offline, the group continues functioning with its current key; no key rotation or membership changes occur until at least one admin returns. |

## Reputation: Bounded Trust-Weighted Referrals

| | |
|---|---|
| **Chosen** | First-hand scores primary; 1-hop trust-weighted referrals as advisory bootstrap for unknown peers, capped and decaying |
| **Alternatives** | Pure first-hand only (no referrals), full gossip-based reputation, global reputation aggregation |
| **Rationale** | Pure first-hand scoring means new nodes have zero information about any peer until direct interaction — leading to poor initial routing and credit decisions. Full reputation gossip enables manipulation: a colluding cluster can flood the network with inflated scores. Global aggregation requires consensus. The chosen design: trusted peers (direct trust edges) can share their first-hand scores as referrals. Referrals are weighted by the querier's trust in the referrer (trust_score / max_score × 0.3) and capped at 50% of max reputation — a referral alone cannot make a peer fully trusted. Only 1-hop referrals are accepted (no transitive gossip), limiting the manipulation surface to corruption of direct trusted peers, which already breaks the trust model. Referral scores are advisory: they initialize a peer's reputation but are overwritten by first-hand experience after the first few direct interactions. Referrals expire after 500 gossip rounds (~8 hours) without refresh. This helps new nodes bootstrap while keeping the attack surface minimal. |

## Onion Routing: Per-Packet Layered Encryption (Opt-In)

| | |
|---|---|
| **Chosen** | Per-packet layered encryption via `PathPolicy.ONION_ROUTE`, stateless relays, 3 hops default, optional cover traffic |
| **Alternatives** | Circuit-based onion routing (Tor-style), mix networks, no onion routing (status quo) |
| **Rationale** | Circuit-based onion routing requires multi-round-trip circuit establishment — on a 1 kbps LoRa link with 2-second round trips, building a 3-hop circuit takes ~12 seconds before any data flows. Mix networks add latency by design (batching and reordering), which is unacceptable for interactive messaging. Per-packet layered encryption has zero setup: the sender wraps the message in N encryption layers (default N=3), each layer containing the next-hop destination hash and the inner ciphertext. Each relay decrypts one layer, reads the next hop, and forwards. No circuit state on relays — each packet is independently routable. Overhead: 32 bytes per hop (16-byte nonce + 16-byte Poly1305 tag), so 3 hops = 96 bytes, leaving 369 of 465 usable bytes on LoRa (~21% overhead). Relay selection: sender picks from known relays, requiring at least one relay outside the sender's trust neighborhood. Optional constant-rate cover traffic (1 dummy packet/minute, off by default) provides additional resistance to timing analysis on high-threat links. Onion routing is opt-in and not recommended for real-time voice (latency and payload overhead). The existing no-source-address design remains the default privacy layer for most traffic. |

## MHR-Byte: 47 Opcodes with Reference Interpreter

| | |
|---|---|
| **Chosen** | 47 opcodes in 7 categories, reference interpreter in Rust, cycle costs calibrated to ESP32 |
| **Alternatives** | Formal specification (Yellow Paper-style), minimal 20-opcode set, EVM-compatible opcode set |
| **Rationale** | A formal specification (Ethereum Yellow Paper style) would freeze the design prematurely — the opcode set needs real-world usage feedback before committing to a formal spec. An EVM-compatible set imports unnecessary complexity (256-bit words, gas semantics) that doesn't fit constrained devices. A minimal 20-opcode set omits crypto and system operations needed for the core use cases. The chosen 47 opcodes cover 7 categories: **Stack** (6): PUSH, POP, DUP, SWAP, OVER, ROT. **Arithmetic** (9): ADD, SUB, MUL, DIV, MOD, NEG, ABS, MIN, MAX — all 64-bit integer, overflow traps. **Bitwise** (6): AND, OR, XOR, NOT, SHL, SHR. **Comparison** (6): EQ, NEQ, LT, GT, LTE, GTE. **Control** (7): JMP, JZ, JNZ, CALL, RET, HALT, ABORT. **Crypto** (3): HASH (Blake3), VERIFY_SIG (Ed25519), VERIFY_VRF. **System** (10): BALANCE, SENDER, SELF, EPOCH, TRANSFER, LOG, LOAD, STORE, MSIZE, EMIT. Cycle costs are tiered: stack/arithmetic/bitwise/comparison (1–3 cycles), control (2–5), memory (2–3), crypto (500–2000), system (10–50). ESP32 is the reference platform (~1 μs per base cycle). Faster hardware executes more cycles per second but charges the same cycle cost — gas price in μMHR/cycle is set by each compute provider. A comprehensive test vector suite ensures cross-platform conformance. Formal specification is a post-stabilization goal. |

## Emission Schedule: Epoch-Counted Discrete Halving

| | |
|---|---|
| **Chosen** | Initial reward of 10^12 μMHR per epoch, discrete halving every 100,000 epochs, tail emission floor at 0.1% of circulating supply annualized |
| **Alternatives** | Continuous exponential decay, wall-clock halving (every 2 calendar years), fixed perpetual emission |
| **Rationale** | Wall-clock halving requires clock synchronization, which contradicts partition tolerance — partitioned nodes would disagree on the current halving period. Continuous decay is mathematically elegant but harder to reason about and implement correctly on integer-only constrained devices. Fixed perpetual emission provides no scarcity signal. Discrete halving every 100,000 epochs is epoch-counted (partition-safe), easy to compute (bit-shift), and predictable. At an estimated ~1 epoch per 10 minutes (varies with network activity since epochs are settlement-triggered), 100,000 epochs ≈ 1.9 years — close to the original 2-year target. Initial reward of 10^12 μMHR/epoch yields ~1.5% of the supply ceiling minted in the first halving period, providing strong bootstrap incentive. Tail emission activates when the halved reward drops below `0.001 × circulating_supply / estimated_epochs_per_year` (trailing 1,000-epoch moving average of epoch frequency). This ensures perpetual relay incentive while keeping inflation negligible. Partition minting interaction: each partition mints `(local_active_relays / estimated_global_relays) × epoch_reward`; on merge, the winning epoch's `epoch_balance` snapshot is adopted and the losing partition's settlements are recovered via settlement proofs, preserving individual balances. Overminting is bounded by the existing partition_scale_factor tolerance (max 1.5×). |

## Protocol Bridges: Standalone Gateway Services

| | |
|---|---|
| **Chosen** | Bridges as standalone gateway services advertising in the capability marketplace; one-way identity attestation; bridge operator bears Mehr-side costs |
| **Alternatives** | Bridges as MHR-Compute contracts, bridge as protocol-level primitive, no bridge design (defer entirely) |
| **Rationale** | MHR-Compute contracts are sandboxed with no I/O or network access — bridges require persistent connections to external protocols (SSB replication, Matrix homeserver federation, Briar Tor transport). A protocol-level primitive over-engineers the foundation for what is fundamentally a gateway service. Bridges run as standalone processes that advertise their bridging capability in the marketplace like any other service. **Identity mapping**: Users create signed bridge attestations linking their Mehr Ed25519 key to their external identity. The bridge stores these attestations and handles translation. No global identity registry — the bridge is the only entity that knows the mapping. External users see messages as coming from the bridge identity in the external protocol. **Payment model**: Mehr-to-external traffic — the Mehr sender pays the bridge operator via a standard marketplace agreement. External-to-Mehr traffic — the bridge operator pays Mehr relay costs and recoups via the external protocol's economics (or operates as a public good). This keeps the Mehr economic model clean: the bridge is just another service consumer/provider. Bridge operators can support multiple protocols simultaneously and set their own pricing. |

## WASM Sandbox: Wasmtime with Tiered Profiles

| | |
|---|---|
| **Chosen** | Wasmtime (Bytecode Alliance) as WASM runtime; two tiers: Light (Community, 16 MB / 10^8 fuel / 5s) and Full (Gateway+, 256 MB / 10^10 fuel / 30s); 10 host imports mirroring MHR-Byte System opcodes |
| **Alternatives** | Wasmer, custom interpreter, single WASM profile for all devices |
| **Rationale** | Wasmtime is Rust-native (matches the reference implementation language), provides fuel-based metering that maps directly to MHR-Byte cycle accounting, and supports AOT compilation on Gateway+ nodes. Wasmer has a broader language ecosystem but less tight Rust integration. A custom interpreter would duplicate Wasmtime's battle-tested sandboxing. A single WASM profile either excludes Community-tier devices (too high limits) or handicaps Gateway nodes (too low limits). Two tiers match the natural hardware split: Pi Zero 2W (512 MB RAM, interpreted Cranelift) vs. Pi 4/5+ (4-8 GB, AOT). Host imports are restricted to 10 functions mirroring MHR-Byte System opcodes — no filesystem, network, clock, or RNG access. WASM execution remains pure and deterministic, enabling the same verification methods as MHR-Byte. Contracts exceeding Light limits are automatically delegated to a more capable node via compute delegation. |

## Presence Beacon: 8-Bit Capability Bitfield

| | |
|---|---|
| **Chosen** | 8 assigned capability bits in 16-bit field; bits 8-15 reserved for future use |
| **Alternatives** | Variable-length capability list, TLV-encoded capabilities, separate beacon per capability |
| **Rationale** | The beacon must fit in 20 bytes total and broadcast every 10 seconds on LoRa — every byte matters. A 16-bit bitfield encodes up to 16 boolean capabilities in 2 bytes, zero parsing overhead. The 8 assigned bits cover all current service types: relay (L1+), gateway, storage, compute-byte, compute-wasm, pubsub, DHT, and naming. Bits 8-15 are reserved (must be zero) for future services like inference, bridge, etc. Variable-length lists or TLV encoding would bloat the beacon and complicate parsing on ESP32. Separate beacons per capability would multiply broadcast bandwidth. |

## Ring 1 Discovery: CapabilitySummary Format

| | |
|---|---|
| **Chosen** | 8-byte `CapabilitySummary` per capability type: type (u8), count (u8), min/avg cost (u16 each, log₂-encoded), min/max hops (u8 each) |
| **Alternatives** | Full capability advertisements forwarded, Bloom filter of providers, free-text summaries |
| **Rationale** | Ring 1 gossips summaries every few minutes — bandwidth must stay under ~50 bytes per round. At 8 bytes per type and typically 5-6 types present in a 2-3 hop neighborhood, the total is 40-48 bytes — within budget even on LoRa. Forwarding full capability advertisements would scale linearly with provider count. Bloom filters compress provider identity but lose cost/distance information needed for routing decisions. The log₂-encoded cost fields match `CompactPathCost` encoding, keeping the representation consistent across the protocol. Count is capped at 255 (u8) — sufficient since Ring 1 covers only 2-3 hops. |

## DHT Metadata: 129-Byte Signed Entries

| | |
|---|---|
| **Chosen** | 129-byte `DHTMetadata`: 32-byte Blake3 key, u32 size, u8 content_type (Immutable/Mutable/Ephemeral), 16-byte owner, u32 TTL, u64 Lamport timestamp, 64-byte Ed25519 signature |
| **Alternatives** | Minimal key-only gossip (no metadata), full object gossip, variable-length metadata with optional fields |
| **Rationale** | DHT publication gossips metadata to let storage-set nodes decide whether to pull full data. Key-only gossip forces blind pulls — wasting bandwidth on unwanted or expired data. Full object gossip floods the gossip channel with arbitrarily large payloads. The 129-byte fixed format includes everything a storage node needs to decide: content hash (for deduplication), size (for storage budgeting), content type (for cache policy), owner (for mutable-object freshness ordering), TTL (for garbage collection), and Lamport timestamp (for mutable conflict resolution). The Ed25519 signature prevents metadata forgery — a node cannot falsely advertise objects it doesn't own. Content hash prevents data forgery on pull. For mutable objects, highest Lamport timestamp with valid signature wins; for immutable objects, the content hash is the sole arbiter. Cache invalidation is TTL-based with no push-invalidation — keeping the protocol simple and partition-tolerant. |

## Negotiation Protocol: Single-Round Take-It-or-Leave-It

| | |
|---|---|
| **Chosen** | Single round-trip negotiation: consumer sends `CapabilityRequest` (with desired cost, duration, proof preference, nonce); provider responds with `CapabilityOffer` (actual terms) or reject; consumer accepts or walks away. 30-second timeout. No counter-offers. |
| **Alternatives** | Multi-round bidding/auction, Dutch auction, sealed-bid auction, negotiation-free fixed pricing |
| **Rationale** | Multi-round negotiation is untenable on LoRa where each message takes seconds — a 3-round negotiation would take 30+ seconds before service begins. Auctions require multiple participants to discover each other simultaneously, which contradicts the bilateral, privacy-preserving nature of agreements. Fixed pricing (no negotiation) removes the consumer's ability to express budget constraints. The single-round protocol: the consumer states their maximum acceptable cost; the provider either meets it, undercuts it, or rejects. One round-trip, then service begins. The nonce in `CapabilityRequest` prevents replay attacks; the `request_nonce` echo in `CapabilityOffer` binds offer to request. Both messages are signed — the two signatures together form the `CapabilityAgreement`. If the consumer wants different terms, they send a new request with adjusted parameters — no counter-offer complexity. This keeps capability negotiation under 2 seconds on WiFi and under 10 seconds on LoRa. |

## Formal Verification: Priority-Ordered TLA+ Targets

| | |
|---|---|
| **Chosen** | TLA+ for concurrent protocol properties; 4-tier priority: (1) CRDT merge, (2) payment channels, (3) epoch checkpoints, (4) full composition deferred |
| **Alternatives** | Coq/Lean theorem proving, no formal verification (testing only), verify everything before v1.0 |
| **Rationale** | Coq/Lean have a steep learning curve that limits contributor access. Pure testing cannot prove absence of bugs in concurrent distributed protocols. Verifying everything delays launch indefinitely. TLA+ is battle-tested for distributed systems (used by Amazon for AWS services, by Microsoft for Azure) and has a practical learning curve. **Priority 1 — CRDT merge convergence** (must verify before v1.0): Prove commutativity, associativity, and idempotency of GCounter max-merge and GSet union. If merge diverges, the entire ledger is broken. **Priority 2 — Payment channel state machine** (must verify before v1.0): Prove no balance can go negative, dispute resolution always terminates within the challenge window, and channel states form a total order by sequence number. Direct financial impact if buggy. **Priority 3 — Epoch checkpoint correctness** (should verify): Prove no confirmed settlement is permanently lost after finalization, bloom filter false positive recovery covers all edge cases during the grace period. Property-based testing (QuickCheck-style) initially, formal TLA+ proof if resources allow. **Priority 4 — Full protocol composition** (defer to post-v1.0): Interaction between subsystems (e.g., channel dispute during epoch transition) is tracked as a long-term research goal. Individual component proofs provide sufficient confidence for launch. |

## Genesis Model: Transparent Service Gateway

| | |
|---|---|
| **Chosen** | Genesis Service Gateway + demand-backed minting + revenue-capped emission |
| **Alternatives** | Pure proof-of-service mining (no genesis), airdrop, ICO, DAO treasury |
| **Rationale** | VRF prevents grinding (one output per relay-packet pair) but does not prevent traffic fabrication: a Sybil attacker can fabricate traffic between colluding nodes and run the VRF lottery on fake packets. A genesis service gateway bootstraps the economy with real demand: a known trusted operator provides real services for fiat, creating funded payment channels that generate legitimate relay traffic. Revenue-capped minting (see below) ensures that even paying through the gateway and self-dealing is unprofitable. The genesis allocation is transparent (visible in ledger from epoch 0). DNS provides initial gateway discovery; the hardcoded bootstrap list serves as fallback. |

## Revenue-Capped Minting

| | |
|---|---|
| **Chosen** | `effective_minting = min(emission_schedule, 0.5 × total_channel_debits)` |
| **Alternatives** | Uncapped emission (vulnerable to self-dealing), fixed low emission (doesn't scale with network growth), proof-of-stake gating (concentrates power) |
| **Rationale** | The revenue cap guarantees that self-dealing is unprofitable at all traffic levels: an attacker spending Y MHR on relay fees can receive at most 0.5 × Y in minting rewards, regardless of their share of the network. This holds for any Y, any epoch, and any number of Sybil nodes. The cap also makes supply growth demand-responsive: during low-usage periods, actual minting is well below the emission schedule (supply grows slowly, preventing speculation). As the network matures and relay fees increase, the cap becomes non-binding and supply follows the standard halving schedule. Fixed low emission was rejected because it doesn't scale — a fixed amount becomes either too generous at low traffic or too stingy at high traffic. Proof-of-stake gating was rejected because it concentrates minting power among large holders. |

## Configurable Transitive Credit Ratio

| | |
|---|---|
| **Chosen** | User-configurable transitive credit ratio (0–50%, default 10%) |
| **Alternatives** | Fixed protocol constant (10%), fully uncapped user choice |
| **Rationale** | Direct credit is already configurable per-peer; transitive ratio should be too. The 50% ceiling prevents naive users from excessive exposure to friend-of-friend defaults. Different communities have different risk appetites — a tight-knit village may want 30% transitive credit, while an urban mesh with loose trust edges may prefer 5%. Per-peer overrides (`transitive_ratio_overrides`) allow fine-grained control. A fixed 10% was too rigid; fully uncapped allows users to set 100%, which could cascade defaults through the trust graph. |

## Single Geo Scope Per Node/Content

| | |
|---|---|
| **Chosen** | Max 1 Geo scope + up to 3 Topic scopes per node/content; total scope data ≤ 1 KB |
| **Alternatives** | Unconstrained (up to 8 of either type), total byte budget only (no count limit), no geo scopes on content |
| **Rationale** | Physical presence is singular — you are in one place at a time. Voting is geo-scoped, and multiple geo scopes would enable double-voting on governance issues. RadioRangeProof verifies one location; multiple geo claims would require multiple independent proofs. Interests are multi-dimensional but hierarchical prefix matching means a single deep tag (e.g., `Topic("gaming", "pokemon", "competitive")`) covers multiple query levels — 3 topic slots is expressive enough for most users. The 1 KB byte cap (down from ~2.1 KB for 8 scopes) halves the scope footprint in announces and envelopes, meaningful for ESP32 and LoRa. A pure byte budget (no count limit) was rejected because it creates a perverse incentive: deep, specific tags cost more bytes, penalizing the most useful scopes. A hard count + byte cap gives predictable allocation for constrained devices while letting the UI show "bytes remaining" (like character counts). |

## Per-Hop Independent Relay Rewards

| | |
|---|---|
| **Chosen** | Per-hop independent rewards (VRF lottery per relay, no end-to-end coordination) |
| **Alternatives** | End-to-end payment (sender pays all relays in one transaction), hybrid (per-hop with end-to-end settlement) |
| **Rationale** | End-to-end payment requires the sender to know the full path, which breaks sender anonymity — packets carry no source address by design. Per-hop stochastic rewards already achieve ~0.3% bandwidth overhead; end-to-end would save negligible additional bandwidth. Per-hop uses simple bilateral channels; end-to-end requires multi-hop payment routing (Lightning-style complexity). Each hop is independent — no coordination failure cascade. If one relay goes offline, only that hop is affected; upstream and downstream relays continue operating on their own bilateral channels. The hybrid approach adds complexity without meaningful benefit over pure per-hop. |

## Variable Packet Sizes with Transport-Class MTU

| | |
|---|---|
| **Chosen** | Three transport classes (Constrained 484B, Standard 1,500B, Bulk 4,096B) with per-link MTU negotiation, passive path MTU discovery via `bottleneck_mtu` in CompactPathCost, and opt-in active route probing |
| **Alternatives** | Fixed 484-byte packets globally (status quo), fully variable with hop-by-hop fragmentation, end-to-end PMTUD (ICMP-style) |
| **Rationale** | The 484-byte Reticulum-derived cap wastes 68–95% of WiFi/Ethernet frame capacity. Transferring 1 MB over WiFi takes 2,151 packets instead of 694. But LoRa's tiny MTU must remain the default for paths that cross constrained links. Transport classes solve this: each link negotiates its MTU during establishment (+3 bytes in handshake), and the `bottleneck_mtu` field in CompactPathCost (1 extra byte per announce) propagates the minimum MTU across the path. Senders size packets to the path — no change for LoRa paths, 3× improvement on pure WiFi, 8.5× on Ethernet/fiber. Hop-by-hop fragmentation was deferred — application-layer chunking (MHR-Store's 4 KB chunks) is simpler and avoids reassembly buffer pressure on ESP32 (520 KB RAM). End-to-end PMTUD requires error signaling from intermediate nodes, which conflicts with sender anonymity. The `PacketTooBig` signal (18 bytes) is sent 1-hop upstream for immediate local correction; the announce system propagates corrected path MTU globally. LoRa links retain fixed-size padding for traffic analysis resistance; WiFi+ links use variable sizes since the threat model differs (encrypted link, no broadcast RF observation). |

## Route Probing: Passive Default with Opt-In Active

| | |
|---|---|
| **Chosen** | Passive path characterization via `bottleneck_mtu` and `bottleneck_bps` in CompactPathCost (always on); active ProbeRequest/ProbeResponse for real-time measurements (opt-in, rate-limited, WiFi+ only) |
| **Alternatives** | Active probing only (ICMP-style), no probing (rely solely on announces), continuous background probing |
| **Rationale** | Passive probing costs 1 byte per announce and gives every node path MTU and bandwidth information for free — a clear win with no downside. Active probing adds real-time RTT and throughput measurement, valuable before voice calls or large transfers, but each probe consumes airtime (~4 seconds at 1 kbps on LoRa). Active probing is therefore restricted to links ≥10 kbps, rate-limited to 1 probe/minute per destination, and exempt from relay rewards to prevent probe flooding for profit. Continuous background probing was rejected — it wastes bandwidth on paths that may never carry user traffic. ICMP-style probing was rejected because it requires end-to-end signaling that conflicts with sender anonymity. |

## Bandwidth Reservation: Hop-by-Hop Progressive Escrow

| | |
|---|---|
| **Chosen** | Hop-by-hop reservation propagation with progressive escrow (10% upfront, per-chunk deterministic payment), VRF bypass during reservations, no `hop_count` in commitment |
| **Alternatives** | Full prepayment, end-to-end reservation (sender specifies path), stochastic relay only (no reservation), circuit-based reservation (Tor-style) |
| **Rationale** | Per-packet stochastic VRF lottery works well for small/interactive traffic but is wasteful for bulk transfers: a 1 GB transfer triggers ~666K VRF operations and ~6,667 channel updates. Bandwidth reservation eliminates VRF overhead entirely — per-chunk (1 MB) deterministic payment yields ~1,024 channel updates for the same 1 GB, a 6.5× reduction. Full prepayment was rejected because it creates moral hazard: a relay already paid in full has no incentive to prioritize the sender's traffic. Progressive escrow aligns incentives — the relay earns as it delivers. End-to-end reservation breaks sender anonymity (sender must know the path). Hop-by-hop propagation preserves the protocol's structural privacy: each relay negotiates only with its direct neighbor, identical to regular packet forwarding. `hop_count` was deliberately excluded from `ReservationCommitment` to prevent path-length deanonymization. The 60-second inactivity rule (non-refundable escrow floor) prevents bandwidth squatting — an attacker must spend real MHR per reservation. Circuit-based reservation was rejected because circuit establishment latency (~12 seconds on LoRa) is unacceptable and requires persistent state on relays. |

---

### Open Questions
<!-- Source: docs/development/open-questions.md -->

# Open Questions

All open questions from the v1.0 and v1.1 spec review rounds have been resolved with concrete specifications.

## Previously Resolved

### v1.1 Resolutions (11 Questions)

#### Architectural — Design Decisions

| # | Question | Resolution | Location |
|---|----------|-----------|----------|
| 1 | **Protocol Governance** — How does the protocol upgrade? | MEP (Mehr Enhancement Proposal) process with trust-weighted version signaling. Nodes signal MEP support via TLV extension in announces; acceptance at ≥67% trust-weighted support. Cross-fork compatibility via gateway bridges. Sunset clause prevents indefinite version limbo. | [Versioning — Governance](/docs/L1-network/versioning#governance) |
| 2 | **Secret Ballot Voting** — Commitment schemes on partition-prone mesh | Two-phase commit/reveal with partition-safe rules: reveal_period = 2× voting_period, 80% reveal threshold for valid tally, INCONCLUSIVE status for >20% unrevealed commits. Deliberate withhold penalized (0.5x weight after 3 consecutive non-reveals). Partition reconciliation via merged re-tally. | [Voting — Secret Ballot](/docs/L6-applications/voting#secret-ballot-protocol) |
| 3 | **Post-Quantum VRF** — No production-ready standard | Two-track approach: lattice-based VRF candidate when standardized; hash-chain committed lottery as fallback. The fallback uses epoch-committed secrets (not proof-of-work) — one Blake3 hash per packet, no grinding. Per-channel migration via existing cryptographic migration phases. | [Versioning — PQ VRF Strategy](/docs/L1-network/versioning#post-quantum-vrf-strategy) |

#### Implementation — Specification

| # | Question | Resolution | Location |
|---|----------|-----------|----------|
| 4 | **AppManifest State Migration** — Execution semantics | Full state delivered via LOAD opcode as CBOR. Success requires HALT + valid CBOR output + schema conformance + within max_cycles. All-or-nothing (no partial migration). Determinism enforced; hash comparison detects violations. No automatic rollback — users pin old manifest hash. | [MHR-App — Migration](/docs/L5-services/mhr-app-upgrades#migration-contract-execution-semantics) |
| 5 | **AppManifest Schema Compatibility** — Formal definition | Programmatic compatibility checker: no removed fields, no type changes, new fields with defaults only, required→optional allowed. CRDT types cannot change between versions. Unknown fields from newer schemas preserved via LWW fallback during merge. | [MHR-App — Schema Compatibility](/docs/L5-services/mhr-app-upgrades#schema-compatibility-rules) |
| 6 | **MHR-Name Cross-Scope Query Routing** — Vague algorithm | DHT-guided scope routing: nodes register as ScopeAnchors at Blake3(scope_string) in DHT. Cross-scope queries look up the scope key, route to nearest anchor by trust distance → hop count → XOR distance. TTL = 5 × gossip_interval (adapts to transport speed). SCOPE_UNREACHABLE returned if no anchor exists. Hierarchical registration ensures ancestor scopes are queryable. | [MHR-Name — Cross-scope queries](/docs/L5-services/mhr-name#trust-weighted-propagation) |
| 7 | **Visibility-Controlled Claim Updates** — Key rotation + versioning | Revoked peers lose forward access (new key), retain historical access (old key). Claims versioned by (claimant, claim_type, qualifier) with created timestamp ordering. Encrypted claims cached as ciphertext; decrypted on key receipt. Partition key rotation reconciled via KEY UNIFICATION when claimant reconnects. | [MHR-ID — Key Rotation and Claim Updates](/docs/L5-services/mhr-id#key-rotation-and-claim-update-semantics) |
| 8 | **Payment Channel Settlement Atomicity** — Protocol not fully specified | Two-phase signing with 120-gossip-round timeout. Half-signed records are never published. After 3 failed attempts: unilateral settlement with 2,880-round challenge window. Strictly all-or-nothing — CRDT ledger only accepts dual-signed records. Channel close via standard 4-epoch abandonment rules. | [Payment Channels — Settlement](/docs/L3-economics/payment-channels#bilateral-payment-channels) |
| 9 | **Gossip Bandwidth Under Congestion** — Enforcement missing | Dedicated gossip token bucket with 2% floor guarantee (min 10 bytes/sec). Gossip throttled (queued), not dropped. Tier 1-2 never dropped. Starvation recovery mode (20% budget) triggered after 10 missed gossip intervals. Weighted fair queuing with strict floor preemption. | [Network Protocol — Gossip Congestion](/docs/L1-network/network-protocol#gossip-congestion-handling) |
| 10 | **Cryptographic Compute Verification** — ZK costs TBD | Decision matrix by workload size. ZK proofs (RISC Zero/SP1/Jolt) viable for contracts up to ~10^6-10^8 cycles at 500-1000x prover overhead. TEE attestation (AMD SEV-SNP, NVIDIA H100 CC) for large models at ~5% overhead. Consumer chooses verification tier; protocol provides framework, market determines adoption. | [MHR-Compute — Cryptographic Verification](/docs/L5-services/mhr-compute#cryptographic-verification-details) |
| 11 | **Voting Hardware Liveness** — No quantified error rates | Multi-feature radio fingerprinting: RSSI pattern (w=0.5) + clock drift/CFO (w=0.35) + timing offset (w=0.15). False positive ~1-5% depending on environment. ~15-30 radios reliably distinguished per km² with 3+ witnesses. Remote voters rely on trust flow + personhood vouching (no hardware liveness); capped at Verified (not StronglyVerified) geo multiplier. | [Voting — Radio Fingerprinting](/docs/L6-applications/voting#radio-fingerprinting-algorithm) |

### v1.0 Resolutions (28 Questions, 5 Rounds)

All questions from the v1.0 spec review rounds (5 rounds, 28 questions total) have been resolved with concrete specifications. The resolution history is preserved in the git log. Key resolution areas:

- **Wire format**: Serialization rules, endianness, TLV extensions, CompactPathCost encoding
- **Timing**: Epoch triggers, DHT rebalancing, beacon collision handling, fragment reassembly
- **Economics**: Settlement timing, channel sequence semantics, credit rate-limiting, difficulty targets
- **Security**: Nonce handling, session key rotation, KeyCompromiseAdvisory replay, reputation initialization
- **Infrastructure**: WASM sandbox tiers, capability bitfield, Ring 1 aggregation, DHT metadata format
- **Design decisions**: Group admin model, reputation gossip, onion routing, MHR-Byte opcodes, emission schedule, protocol bridges, formal verification targets

---

### Design Decision: Partition Defense
<!-- Source: docs/development/partition-defense-comparison.md -->

# Distributed Exchange vs Trust Graph: Partition Defense Comparison

The [isolated partition attack](/docs/L3-economics/token-security#attack-isolated-partition) is the most significant economic threat to Mehr's CRDT-based ledger. An attacker runs 100 virtual nodes on a single machine (~$60/year), isolates them in a partition, and mints MHR uncontested. Post-bootstrap (epoch > 100,000), [GenesisAttestation](/docs/L3-economics/mhr-token#genesis-anchored-minting) sunsets and the network needs a **fully distributed** defense — no genesis root, no central authority.

Two architectures address this:

| | **A: Trust-Gated Active Set + Merge-Time Audit** | **B: Neighborhood-Scoped Minting** |
|---|---|---|
| **One-liner** | One global MHR. Minting requires trust links. Untrusted minting rejected on merge. | Local currencies per neighborhood. Cross-neighborhood exchange at market rates. |
| **Defense type** | Retroactive — minting audited when partitions reconnect | Structural — attacker tokens are a different currency |
| **Status** | **Current design** | Not adopted — see [rationale](#rationale) |

## The Problem

During bootstrap (epoch 0–100,000), [GenesisAttestation](/docs/L3-economics/mhr-token#genesis-anchored-minting) prevents all isolated partition minting by requiring a signed proof of connectivity to a genesis node. This works but is centralized — every attestation chain traces back to one root.

Post-bootstrap, three approaches are possible:

1. **Make GenesisAttestation permanent** — Not viable. This is "centralization with extra steps." Every attestation chain forever traces back to genesis. A community that forms after bootstrap and has never connected to the genesis graph can never mint. Not distributed.

2. **Trust-gated active set + merge-time audit** — Current design. Uses the existing trust graph as a minting gate. Merge-time audit rejects untrusted partition minting on reconnection. Fully distributed post-bootstrap.

3. **Neighborhood-scoped minting** — Not adopted. Each neighborhood mints its own denomination with cross-neighborhood exchange. Structurally eliminates the attack but creates massive new complexity.

## Approach A: Trust-Gated Active Set + Merge-Time Audit

### Design

**Continuous gate** (connected network):
- A node is **minting-eligible** if it is in the [active set](/docs/L3-economics/epoch-compaction#epoch-lifecycle) AND has ≥1 mutual trust link with another active-set member
- "Mutual trust link" = both nodes have each other in `trusted_peers`
- This is a soft Sybil gate — it doesn't prevent the partition attack (attacker nodes trust each other) but provides basic hygiene in the connected network

**Merge-time defense** (partition reconnection):
- When a partition reconnects, CRDT data merges normally (unconditional convergence)
- The **minting component** is audited: cross-partition trust scoring determines what fraction of partition minting is accepted
- `partition_trust_score = (nodes trusted by main-network peers) / (total partition nodes)`
- Untrusted minting enters quarantine (10 epochs), then is permanently rejected if unproven
- See [merge-time trust audit](/docs/L3-economics/token-security#merge-time-trust-audit) for full spec

### Attack Outcomes

| Scenario | Dilution |
|---|---|
| Fresh localhost (100 virtual nodes, 0 trust) | **0.00%** |
| Pre-planned, 1/100 nodes trusted by main network | **0.99%** |
| Pre-planned, 10/100 trusted | 9.09% |
| Deep infiltration, 50/100 trusted | 33.33% |
| Extreme infiltration, 90/100 trusted | 47.37% |

### Properties

- **Fully distributed**: No genesis dependency post-bootstrap. Trust graph is the only authority.
- **One global currency**: MHR is MHR everywhere. Zero exchange friction.
- **Backward compatible**: Nodes that haven't implemented the audit yet degrade gracefully.
- **CRDT-safe**: Audit is an economic overlay on convergent data, not a modification to CRDT merge.
- **~500 lines of new code**: Trust-link check on active set + merge-time audit logic.

## Approach B: Neighborhood-Scoped Minting

### Design

**Local currencies**:
- Each trust neighborhood mints its own denomination: MHR-Portland, MHR-Tehran, MHR-Attacker
- A `neighborhood_tag` (trust anchor hash) tags every minted unit
- Cross-neighborhood payments use bilateral exchange channels at market-negotiated rates
- Exchange rate = supply/demand at boundary nodes (nodes in multiple neighborhoods)

**Structural defense**:
- Attacker creates "MHR-Attacker" in their isolated partition
- Zero real services → zero demand for MHR-Attacker → zero exchange rate
- No impact on any other neighborhood's economy
- The market IS the proof: tokens backed by nothing have no value

### Attack Outcomes

| Scenario | Dilution on honest neighborhoods |
|---|---|
| Fresh localhost (any number of nodes) | **0.00%** (different currency) |
| Pre-planned, any trust level | **0.00%** (different currency) |
| Deep infiltration, any level | **0.00%** (different currency) |
| Attacker provides 10% real services | ~9.09% (exchange rate reflects real services) |
| Attacker provides 50% real services | ~33.33% (exchange rate reflects real services) |

### Properties

- **Fully distributed**: Each neighborhood is self-sovereign. No external dependency.
- **Structurally immune**: Attack produces worthless tokens by definition.
- **Perfect partition tolerance**: Each partition IS its own economy. No merge conflict ever.
- **~5,000+ lines of new code**: Cross-denomination channels, exchange rate protocol, wallet UX.

## Head-to-Head Comparison

### Security

| Attack | A: Trust-Gated+Audit | B: Neighborhood-Scoped |
|---|---|---|
| Fresh identities (the real threat) | **0%** | **0%** |
| 1% trust infiltration | 0.99% | 0% |
| 50% trust infiltration | 33.3% | 0% |
| Attacker provides 50% real services | N/A (one currency) | 33.3% |

**Verdict**: Tied for realistic attacks (fresh IDs). B wins on deep infiltration. But if the attacker in B provides real services (the only way to get exchange value), dilution converges to the same numbers — B just shifts the attack surface from "trust infiltration" to "exchange rate manipulation."

### User Experience

| Scenario | A | B |
|---|---|---|
| Pay for service in your city | Send MHR | Send MHR-Portland |
| Pay for service in another city | Send MHR (same currency) | Exchange MHR-Portland → MHR-Tehran, then send |
| Move to a new city | Nothing changes | Must exchange all tokens |
| Check your balance | "1,000 MHR" | "800 MHR-Portland + 150 MHR-Tehran + 50 MHR-Guild" |
| New node joining | Add a contact, start minting | Join neighborhood, get local denomination |

**Verdict**: A wins decisively. B imposes foreign exchange friction on every cross-community interaction.

### Implementation Complexity

| Component | A | B |
|---|---|---|
| Active set | Add trust-link check (~20 lines) | Add `neighborhood_tag` to active set |
| CRDT ledger | Merge-time audit (already spec'd) | `epoch_balance` becomes per-denomination. GCounter entries tagged. Major rework. |
| Payment channels | No change | Cross-denomination channels: new type, exchange negotiation, dual-currency settlement. Major rework. |
| Emission schedule | No change | Per-neighborhood emission with neighborhood size tracking |
| New protocol | Trust proofs at merge (~200 bytes) | Exchange rate gossip, cross-denom channel ops (~5 new message types) |
| Wallet UX | No change | Multi-denomination display, exchange interface |
| **Total** | **~500 lines** | **~5,000+ lines** |

**Verdict**: A is 10x simpler. B requires changes to nearly every economic subsystem.

### Architecture

| Concern | A | B |
|---|---|---|
| Single global currency | **Preserved** | Destroyed — MHR becomes a token family |
| CRDT properties | Preserved entirely (audit is economic overlay) | GCounter merge becomes denomination-aware |
| Existing spec changes | Moderate (mhr-token.md, crdt-ledger.md) | Massive (every economic doc) |
| Backward compatible | Yes (graceful degradation) | No (breaking change) |

**Verdict**: A is a surgical addition. B is a fundamental architecture change.

### Philosophy

| Principle | A | B |
|---|---|---|
| Distributed? | Yes — trust graph is sole authority | Yes — each neighborhood self-sovereign |
| Communities first? | Communities share one economy. Free local, paid global. | Communities own their economy. Free local, exchange at boundary. |
| Partition tolerance? | Good — minting works during isolation, audited on merge | Perfect — each partition is its own economy |
| Simplicity? | High — one currency, one wallet | Low — multi-currency management |
| Real-world parallel | One country, one dollar (with post-partition audit) | Multi-country with forex markets |

**Verdict**: Philosophical tie. A favors cohesion ("one MHR for everyone"). B favors sovereignty ("each community controls its money"). Both are valid readings of "communities first."

### Edge Cases

| Edge Case | A | B |
|---|---|---|
| 1-node neighborhood | Works — gets trust from any peer, mints global MHR | Mints into local denomination with zero liquidity |
| Nomadic user | MHR works everywhere | Must exchange on every move |
| Bridge node (2 neighborhoods) | Normal node | Must hold 2 denominations, provides liquidity |
| Adversarial exchange rate manipulation | N/A (one currency) | **New attack surface** — attacker manipulates rates between neighborhoods |
| New neighborhood forming | Any trusted peer → in | Must create new denomination. Who accepts your new token? (Chicken-and-egg) |

**Verdict**: A handles edge cases naturally. B creates new problems for single-node communities, nomadic users, and new neighborhoods.

## Design Rationale {#rationale}

1. **Security is equivalent for practical attacks.** Both produce 0% dilution for fresh-identity localhost attacks — the realistic, cheap threat. The gap is deep trust infiltration (50%+ of attacker nodes pre-trusted by real people). This requires sustained social engineering, is slow, visible, and doesn't scale. It's also bounded by the halving schedule.

2. **Approach B solves one problem by creating three.** Exchange rate manipulation, liquidity bootstrapping, and cross-denomination UX are each individually harder unsolved problems than the partition attack itself.

3. **10x simpler.** ~500 lines vs ~5,000+. Zero changes to payment channels, wallet UX, or protocol messages. The merge-time audit is already specified in [crdt-ledger.md](/docs/L3-economics/epoch-compaction#merge-time-supply-audit).

4. **B hurts legitimate users more than attackers.** Users moving between cities, paying for cross-community services, or running multi-region applications all face exchange friction. The attacker pays zero (their tokens are worthless either way).

5. **A is more "communities first."** Communities share a global commons (one MHR), communicate freely within trust boundaries, and pay at the boundary. This matches Mehr's ethos better than fragmenting the economy into sovereign micro-currencies.

### Residual Risk

The remaining exposure in Approach A is **deep trust infiltration** — an attacker who gets ≥50% of their partition nodes trusted by main-network peers before isolating. This worst case produces ~33% dilution per cycle.

Mitigations:
- This requires **sustained social engineering** — building real trust relationships with real people who will absorb your debts. This is the hardest, slowest, most visible form of attack in any system.
- The **halving schedule** bounds cumulative damage. Each halving period (~1.9 years), attacker per-epoch minting halves.
- **Per-cycle visibility**: The attacker must reconnect to spend the minted MHR, making each cycle observable.
- If deep infiltration proves to be a **practical** problem (observed in the wild, not just theoretical), neighborhood-scoped minting can be introduced as a network evolution: A → A+B (dual-mode) → B (if needed). This should be a response to observed attacks, not a pre-emptive architectural bet.

### Key Insight

The partition attack is about **minting**. Neighborhood-scoped minting solves it by making minting local. But the merge-time trust audit solves it just as well for all realistic attacks, without fragmenting the economy. The ~33% worst case requires social engineering at scale — which is already the hardest attack vector in any distributed system.

## Quantitative Model

The full analysis with dilution calculations across all scenarios is in the [defense comparison script](https://github.com/mehr-network/mehr-docs/blob/main/scripts/defense_comparison.py). The [localhost partition analysis](https://github.com/mehr-network/mehr-docs/blob/main/scripts/localhost_partition_analysis.py) demonstrates the cost gap that motivates this defense.

---

### Landscape Analysis
<!-- Source: docs/development/landscape.md -->

# Landscape Analysis

An honest comparison of Mehr against existing decentralized and mesh networking projects. The individual pieces of Mehr aren't novel — the combination is. Every feature exists somewhere else. What no existing project does is combine them all into a single coherent stack.

---

## Prior Art by Feature

| Mehr Feature | Who Did It First / Best |
|---|---|
| Transport-agnostic mesh | [Reticulum](https://reticulum.network/) — Mehr builds on it |
| LoRa mesh messaging | [Meshtastic](https://meshtastic.org/), [goTenna](https://gotenna.com/) |
| Cryptographic identity (no registrar) | [SSB](https://scuttlebutt.nz/), [Briar](https://briarproject.org/), Reticulum, many others |
| Content-addressed storage | [IPFS](https://ipfs.tech/) (2015) |
| Decentralized storage market | [Filecoin](https://filecoin.io/) |
| Paid mesh relay | [Althea](https://althea.net/) (mesh ISP economics) |
| Token incentives for infrastructure | [Helium](https://www.helium.com/) (DePIN) |
| CRDT-based state (no blockchain) | [Holochain](https://www.holochain.org/) (agent-centric + mutual credit) |
| Onion routing | [Tor](https://www.torproject.org/) (2002), [I2P](https://geti2p.net/) |
| Offline-first social | [SSB](https://scuttlebutt.nz/) (append-only feeds, gossip replication) |
| No-source-address privacy | Reticulum |
| DHT routing | Kademlia (2002), used by IPFS, BitTorrent, etc. |
| Erasure coding for storage | Standard technique (Reed-Solomon), Filecoin uses it |
| Smart contracts / compute | Ethereum, Filecoin FVM, Holochain |

---

## Project-by-Project Comparison

### Reticulum

[Reticulum](https://reticulum.network/) is the closest spiritual ancestor — Mehr explicitly builds on its transport layer.

**What it does**: A cryptography-based networking stack for building networks over any medium. Replaces IP-based networking with destination-hash-based addressing using Ed25519 keys.

**Transport**: Fully transport-agnostic. LoRa (via RNode), packet radio, WiFi, Ethernet, serial, BLE, free-space optical, AX.25. Proven on links as slow as 5 bps. TCP/IP can also serve as a carrier.

**Economics**: None. No token, no node compensation. Purely volunteer/altruistic relay.

**Storage**: None. Transport-only stack.

**Compute**: None.

**Privacy**: Strong. No source address in packets (structural sender anonymity). AES-256-CBC with ephemeral ECDH on Curve25519, forward secrecy.

**Constrained devices**: ESP32 serves as radio modem, but the Reticulum stack itself runs on the host (Python on Raspberry Pi or Linux).

**Partition tolerance**: Excellent. Designed for partitioned operation.

**Mehr adds**: Everything above transport — economics, storage, compute, marketplace, social. Reticulum is Layer 0; Mehr is Layers 1-6.

---

### Meshtastic

**What it does**: Open-source firmware that turns cheap LoRa hardware into off-grid mesh communicators. Text messaging and position sharing.

**Transport**: LoRa only for mesh hops. BLE for phone pairing, WiFi for configuration/MQTT bridge.

**Economics**: None.

**Storage**: Minimal store-and-forward for offline messages.

**Privacy**: Limited. AES-256 with a shared pre-shared key — all channel members share the same key.

**Constrained devices**: Runs natively on ESP32 and nRF52840. $15-50 per node.

**Partition tolerance**: Good for broadcasts. Direct messages can fail if the path breaks.

**Mehr adds**: Multi-transport bridging, economic incentives, content-addressed storage, DHT, compute, per-message E2E encryption (not shared PSK), cost-aware routing.

---

### Helium

**What it does**: Decentralized wireless infrastructure (DePIN) providing LoRaWAN for IoT and mobile coverage (5G/WiFi). Hotspot operators earn tokens.

**Transport**: LoRaWAN + WiFi/CBRS 5G. Hotspots connect to the Solana blockchain via internet backhaul. Star topology — not a mesh between hotspots.

**Economics**: HNT token on Solana. Proof of Coverage + data transfer rewards. Data Credits at fixed $0.00001, created by burning HNT.

**Storage**: None.

**Privacy**: Minimal. Hotspot locations are public. All transactions on a public blockchain.

**Constrained devices**: Hotspots require dedicated hardware ($200-500) with persistent internet and power.

**Partition tolerance**: Poor. Each hotspot requires continuous internet. No mesh between hotspots.

**Mehr adds**: Actual mesh topology, partition tolerance, no blockchain dependency, storage + compute, operation without internet.

---

### IPFS / Filecoin

**What it does**: IPFS is a content-addressed distributed file system. Filecoin adds economic incentives for persistent storage. libp2p is the networking library.

**Transport**: libp2p supports TCP, QUIC, WebSocket, WebRTC — but assumes internet connectivity. No LoRa or radio transport.

**Economics**: Filecoin FIL token. Storage providers earn FIL via Proof of Spacetime and Proof of Replication. Clients pay FIL to store data. On-chain settlement.

**Storage**: Core feature. Content-addressed blocks (CIDs) with Kademlia DHT. Filecoin adds persistence guarantees with cryptographic proofs.

**Compute**: Emerging. Filecoin Virtual Machine (FVM) is WASM-based. Compute-over-data in development (Bacalhau project).

**Privacy**: Limited. Data is public by default. No built-in encryption. Filecoin deals are on a public blockchain.

**Constrained devices**: Cannot run on constrained devices. Filecoin storage providers need GPUs for proof generation.

**Partition tolerance**: Moderate for IPFS (content available from any node that has it). Poor for Filecoin (proofs must be submitted to blockchain on schedule).

**Mehr adds**: Transport agnosticism, constrained-device support, no blockchain dependency, partition-tolerant economics, trust-based free tier, mesh radio capability.

---

### Holochain

**What it does**: Agent-centric distributed application framework. Each participant maintains their own signed hash chain and shares data to a DHT. No global consensus.

**Transport**: Internet-based (TCP/WebSocket). No radio or constrained transport support.

**Economics**: HoloFuel mutual-credit currency — balances created by counterparties, not minted from fixed supply. Fundamentally different from token-based systems.

**Storage**: Via validating DHT. Each app defines its own DNA (validation rules). Data sharded across responsible nodes.

**Compute**: Yes — each hApp runs application logic on participating nodes.

**Privacy**: Moderate. Source chains are private. DHT entries can be encrypted. No onion routing.

**Constrained devices**: Can run on Raspberry Pi. Far too heavy for microcontrollers.

**Partition tolerance**: Excellent. Agent-centric model means partitioned networks continue operating independently.

**Mehr adds**: Radio mesh transport, constrained-device support (ESP32), bandwidth-aware protocol design for LoRa, cost-aware routing, integrated connectivity marketplace.

---

### Scuttlebutt (SSB)

**What it does**: Peer-to-peer social networking via append-only logs and gossip. Offline-first, community-centric.

**Transport**: LAN discovery via multicast UDP. Internet via "Pub" relay servers. Direct TCP connections. No radio support.

**Economics**: None. Pubs run by volunteers.

**Storage**: Distributed through social graph replication — each node stores feeds of friends (and optionally friends-of-friends). No DHT.

**Privacy**: Moderate. Secret Handshake protocol authenticates connections. Private messages use asymmetric encryption. Social graph is visible.

**Constrained devices**: Requires Node.js (JavaScript implementation) or similar. Not suitable for microcontrollers.

**Partition tolerance**: Excellent. SSB's strongest feature. Feeds are append-only and self-certifying.

**Mehr adds**: Economic incentives, radio mesh, constrained-device support, content-addressed storage with erasure coding, DHT, compute contracts, cost-aware routing.

---

### Briar

**What it does**: Secure messenger for activists and journalists. Zero reliance on central infrastructure.

**Transport**: Multi-transport — Tor (internet), Bluetooth (10-30m), WiFi Direct. Also USB sneakernet. This multi-transport approach is similar to Mehr's philosophy, though narrower in scope.

**Economics**: None.

**Storage**: Messages stored encrypted on-device only.

**Privacy**: Excellent. E2E encryption, Tor routing hides metadata. Passed independent security audit (Cure53).

**Constrained devices**: Android app (primary). Desktop (beta). Cannot run on microcontrollers.

**Partition tolerance**: Good. Bluetooth and WiFi Direct work without internet. Cannot discover new peers in a partition.

**Mehr adds**: Economic incentives, extended range (LoRa), storage + compute services, DHT, cost-aware routing, social features.

---

### Matrix

**What it does**: Open standard for decentralized, federated real-time communication. Interoperable messaging and VoIP across independent homeservers.

**Transport**: HTTP/HTTPS over TCP/IP. WebSocket for clients. Assumes internet at all times.

**Economics**: None at protocol level. Homeserver operators bear costs.

**Storage**: Homeservers replicate room state. Not content-addressed.

**Privacy**: Moderate-Good. Olm/Megolm E2E encryption. Metadata visible to homeserver operators.

**Constrained devices**: Homeservers require server-class hardware. Not suitable for constrained devices.

**Partition tolerance**: Poor. Federation requires internet. Offline homeserver = unreachable users.

**Mehr adds**: Transport agnosticism, mesh radio, no server dependency, economic incentives, partition tolerance, constrained-device support.

---

### Hyphanet (formerly Freenet)

**What it does**: Censorship-resistant publishing and communication. Anonymous distributed data storage.

**Transport**: Internet-only (TCP/IP). No radio or mesh.

**Economics**: None. Volunteer node operators.

**Storage**: Core feature. Encrypted chunks distributed across the network. Content persists based on popularity.

**Privacy**: Strong. Two modes: Opennet (random connections) and Darknet (trusted peers only). Multi-layer encryption. Publishers and retrievers are anonymous.

**Constrained devices**: Requires Java runtime and persistent disk (10-20 GB). Cannot run on constrained devices.

**Partition tolerance**: Moderate. Darknet mode tolerates some fragmentation. Content availability degrades with partition size.

**Mehr adds**: Radio mesh transport, constrained-device support, economic incentives, cost-aware routing, compute contracts, integrated service marketplace.

---

### Althea

**What it does**: Protocol for decentralized ISP operation. Routers negotiate bandwidth pricing and route payments automatically.

**Transport**: Standard IP networking (WiFi, Ethernet, point-to-point wireless bridges). Uses Babel routing protocol. Not designed for LoRa or constrained radio.

**Economics**: Token-based. Routers pay neighbors per-byte for forwarding. Althea L1 blockchain for governance. Liquid Infrastructure Tokens (LITs) represent revenue-generating assets.

**Storage**: None. Connectivity protocol only.

**Privacy**: Limited. Traffic routing and payments are transparent between nodes. Standard ISP-like model.

**Constrained devices**: Requires OpenWrt-compatible routers. Not suitable for microcontrollers.

**Partition tolerance**: Poor. Economic model requires blockchain access for settlement.

**Mehr adds**: Radio mesh (LoRa), constrained-device support, no blockchain dependency, partition-tolerant economics (CRDT ledger), storage + compute, trust-based free tier.

---

### goTenna

**What it does**: Hardware mesh networking devices for off-grid communication. Primarily targets first responders and military. Proprietary closed-source protocol.

**Transport**: Proprietary radio on VHF/UHF bands. Bluetooth for phone pairing. No internet connectivity — purely radio mesh.

**Economics**: Hardware sales ($849+ per Pro X2 unit). Previously explored token incentives (Lot49 protocol) but did not commercialize.

**Storage**: None beyond store-and-forward.

**Privacy**: Moderate. 384-bit ECC E2E encryption. But proprietary and closed-source — no independent verification.

**Constrained devices**: Requires purchasing proprietary hardware. Cannot use off-the-shelf components.

**Partition tolerance**: Excellent for messaging. Zero-control-packet approach minimizes overhead.

**Mehr adds**: Open protocol, off-the-shelf hardware, economic incentives, storage + compute, DHT, social features, internet bridging, transport agnosticism.

---

### Yggdrasil / CJDNS

**What they do**: Encrypted IPv6 overlay networks with self-healing mesh routing. Cryptographic addresses derived from public keys.

**Transport**: Overlay on existing IP networks. Cannot run on non-IP transports.

**Economics**: None. Volunteer-operated.

**Storage**: None. Routing-only overlays.

**Privacy**: Moderate. All traffic encrypted. Addresses derived from keys. No onion routing — traffic analysis possible.

**Constrained devices**: Yggdrasil (Go) and CJDNS (C) can run on Raspberry Pi and OpenWrt routers. Cannot run on bare microcontrollers.

**Partition tolerance**: Good. Self-healing routing adapts to topology changes.

**Mehr adds**: Radio mesh transport, economic incentives, storage + compute, constrained-device support (ESP32), capability marketplace.

---

### Tor / I2P

**What they do**: Anonymous overlay networks. Tor: circuit-switched onion routing for internet access and hidden services. I2P: packet-switched garlic routing for internal services.

**Transport**: Internet-only. TCP (Tor) or UDP (I2P). Completely non-functional without internet.

**Economics**: None. Volunteer-operated relays.

**Storage**: None.

**Privacy**: Very strong. Multi-hop onion/garlic routing with layered encryption. Tor: 3 hops + directory authorities. I2P: 6-hop unidirectional tunnels.

**Constrained devices**: Cannot run on constrained devices.

**Partition tolerance**: None. Requires internet connectivity.

**Mehr adds**: Transport agnosticism (works without internet), economic incentives, storage + compute, constrained-device support, partition tolerance. Mehr's optional onion routing (`PathPolicy.ONION_ROUTE`) provides privacy for high-threat scenarios without requiring always-on anonymization.

---

### Session

**What it does**: Privacy-focused messenger requiring no phone number or email. Onion routing over a decentralized network of staked nodes.

**Transport**: Internet-based. Three-hop onion routing through Session Nodes. Session Network blockchain for staking and rewards.

**Economics**: Session Token (migrated from OXEN in 2025). Node operators stake tokens and earn rewards for routing and storage.

**Storage**: Temporary. Swarm-based message storage for offline delivery. Not general-purpose.

**Privacy**: Very strong. No registration info required. Onion routing hides IPs. E2E encryption.

**Constrained devices**: Clients on phones/desktops. Session Nodes require server-class hardware. Not suitable for microcontrollers.

**Partition tolerance**: Poor. Requires internet to reach Session Nodes.

**Mehr adds**: Transport agnosticism, mesh radio, constrained-device support, general-purpose storage + compute, no blockchain dependency, partition tolerance, trust-based free relay.

---

### Nostr

**What it does**: Minimalist protocol for decentralized social networking. Cryptographic keys for identity, relays for message distribution.

**Transport**: WebSocket connections to relay servers. Assumes internet.

**Economics**: No built-in token. Relay operators may charge. Lightning Network zaps for tipping.

**Storage**: Relays store events. No content-addressing, no DHT, no erasure coding. Persistence depends entirely on relay willingness.

**Privacy**: Weak. Events typically unencrypted. Relays see all content and metadata. IP addresses visible.

**Constrained devices**: Clients are lightweight. Relays need server hardware.

**Partition tolerance**: Moderate. Clients can connect to any subset of relays.

**Mehr adds**: Transport agnosticism, mesh radio, constrained-device support, protocol-level economic incentives, content-addressed storage with erasure coding, DHT, compute, E2E encryption by default, partition tolerance.

---

### Safe Network (formerly MaidSafe)

**What it does**: Fully autonomous, decentralized data network aiming to replace the client-server model. Self-managing with no human oversight.

**Transport**: Internet-based P2P. No radio or constrained transport support.

**Economics**: Token-based. MaidSafeCoin (MAID) placeholder; Safe Network Tokens (SNT) at mainnet. Users pay for storage; node operators earn for providing resources.

**Storage**: Core feature. Self-encryption, chunking, distributed across the network. Node operators cannot read stored content.

**Privacy**: Very strong by design. Self-encryption ensures data is encrypted before leaving the user's device.

**Constrained devices**: Intended for consumer hardware. Not suitable for microcontrollers.

**Partition tolerance**: Moderate. Section-based architecture tolerates some fragmentation but requires significant connectivity.

**Note**: After 18+ years of development, the project remains in alpha.

**Mehr adds**: Radio mesh transport, constrained-device support, partition tolerance as first-class constraint, shipping strategy (server-first, proven layers before extending).

---

### Dat / Hypercore Protocol

**What it does**: Peer-to-peer data sharing based on append-only, cryptographically signed logs (Hypercores). Now developed as the Pear Runtime for P2P applications.

**Transport**: Internet-based. Hyperswarm handles discovery via DHT with NAT holepunching. Supports LAN discovery. No radio.

**Economics**: None. Purely voluntary replication.

**Storage**: Yes. Append-only logs with Merkle tree verification. Partial replication — peers download only ranges they need. Hyperdrive provides file system abstraction. No incentive to store others' data.

**Privacy**: Limited. Hypercores identified by public keys. No encryption at rest by default. DHT exposes interest metadata.

**Constrained devices**: Node.js-based. Not suitable for microcontrollers.

**Partition tolerance**: Good. Append-only logs are inherently partition-tolerant.

**Mehr adds**: Economic incentives for storage, radio mesh, constrained-device support, erasure coding, cost-aware routing, compute contracts.

---

## Comparison Matrix

How each project maps to Mehr's key design axes.

| Project | Transport Agnostic | Token / Economics | Storage | Compute | Privacy | Runs on MCU | Partition Tolerant |
|---|---|---|---|---|---|---|---|
| **Mehr** | **Yes** (LoRa to fiber) | **Yes** (VRF lottery, CRDT ledger) | **Yes** (erasure-coded) | **Yes** (MHR-Byte + WASM) | **Yes** (no source addr + opt-in onion) | **Yes** (ESP32) | **Yes** (economic convergence) |
| Reticulum | **Yes** | No | No | No | **Yes** | Partial (modem only) | **Yes** |
| Meshtastic | LoRa only | No | No | No | Weak (shared PSK) | **Yes** | **Yes** |
| Helium | LoRaWAN + WiFi | **Yes** (HNT/Solana) | No | No | No | No | No |
| IPFS / Filecoin | IP only | **Yes** (FIL) | **Yes** | Partial (FVM) | No | No | Partial |
| Holochain | IP only | **Yes** (mutual credit) | **Yes** (DHT) | **Yes** (hApps) | Partial | No | **Yes** |
| SSB | LAN + internet | No | Partial (social graph) | No | Partial | No | **Yes** |
| Briar | Tor + BT + WiFi | No | No | No | **Yes** | No | Partial |
| Matrix | HTTP only | No | Partial (room state) | No | Partial (E2EE) | No | No |
| Hyphanet | TCP only | No | **Yes** | No | **Yes** | No | Partial |
| Althea | WiFi / Ethernet | **Yes** (blockchain) | No | No | No | No | No |
| goTenna | Proprietary radio | No | No | No | Partial | Proprietary HW | **Yes** |
| Yggdrasil / CJDNS | IP overlay | No | No | No | Partial | No | Partial |
| Tor / I2P | Internet only | No | No | No | **Yes** | No | No |
| Session | Internet only | **Yes** (staking) | Partial (temp msgs) | No | **Yes** | No | No |
| Nostr | WebSocket | Partial (Lightning) | Partial (relays) | No | No | No | Partial |
| Safe Network | Internet only | **Yes** (planned) | **Yes** (planned) | Partial (planned) | **Yes** | No | Partial |
| Dat / Hypercore | IP + LAN | No | **Yes** (append logs) | No | No | No | Partial |

---

## What's Actually Novel

Six aspects of Mehr's design have no direct equivalent in existing projects:

### 1. ESP32-to-Datacenter Unified Economic Protocol

No project spans this hardware range with a single economic protocol. Meshtastic runs on ESP32 but has no economics. Filecoin has economics but needs GPUs. Holochain needs at minimum a Raspberry Pi. Mehr's [three participation levels](/docs/L0-physical/physical-transport#participation-levels) (L0 transport-only, L1 relay with lottery, L2 full node) let a $5 microcontroller and a datacenter server participate in the same economy.

### 2. Stochastic Relay Rewards via VRF Lottery

Althea does paid relay but settles on a blockchain. Helium uses Solana. Mehr's [VRF lottery](/docs/L3-economics/payment-channels) reduces channel state updates by ~10x compared to per-packet payment, and the [CRDT ledger](/docs/L3-economics/crdt-ledger) converges without consensus. The specific mechanism — ECVRF-ED25519-SHA512-TAI lottery, bilateral payment channels, CRDT settlement, epoch compaction — doesn't exist elsewhere as a complete system.

### 3. Economic Partition Tolerance

SSB and Holochain handle *data* partition tolerance well. No project addresses what happens to *money* when the network splits. Mehr's CRDT ledger with [partition-aware epoch compaction](/docs/L3-economics/epoch-compaction#epoch-triggers), GCounter rebase, and bounded overminting (max 1.5x) is designed for the case where a village on LoRa is a permanent partition with its own functioning economy.

### 4. Trust-Based Free Tier Integrated with Paid Economics

CJDNS and Hyphanet's darknet use friend-of-friend topology, but without economics on top. Mehr's [trust graph](/docs/L3-economics/trust-neighborhoods) lets friends relay for free while the same protocol charges strangers — and the boundary is fluid. No other project makes this the core economic primitive, with the paid layer activating only when traffic crosses trust boundaries.

### 5. Cost-Aware Kleinberg Small-World Routing

No existing project combines formal small-world routing (O(log² N) hop guarantee) with per-link economic cost metrics. Reticulum has announce-based path discovery but no cost awareness. Althea has cost-aware routing but uses Babel (distance-vector, not small-world optimized). Mehr's [routing model](/docs/L1-network/network-protocol#routing) provides both scalability guarantees and economic efficiency.

### 6. Integrated Capability Marketplace

Filecoin does storage + emerging compute. Althea does connectivity. Holochain does storage + compute. No single project unifies storage, compute, and connectivity into one [discovery/negotiation/verification/payment framework](/docs/L4-marketplace/overview) where a node advertises whatever it can do and the market determines its role.

---

## The Closest Projects

Four projects come closest to Mehr's vision, each covering one or two layers:

| Project | What It Covers | What It Lacks |
|---|---|---|
| **Reticulum** | Transport + routing + identity (Layer 0-1) | Economics, storage, compute, marketplace |
| **Holochain** | Agent-centric data + mutual credit + apps | Radio mesh, constrained devices, bandwidth-aware design |
| **Althea** | Mesh ISP economics + paid relay | Radio mesh, storage, compute, partition tolerance (needs blockchain) |
| **IPFS / Filecoin** | Content-addressed storage + emerging compute market | Radio mesh, constrained devices, partition tolerance (needs blockchain) |

Mehr's contribution is integrating these into a single stack that runs from ESP32 to datacenter, works without internet, and converges economically after network partitions.

---

### Design Rationale: Variable Packet Size & Route Probing
<!-- Source: docs/development/variable-packet-size.md -->

# Design Rationale: Variable Packet Size & Route Probing

> **Status**
**Specified in v1.0.** This page summarizes the design rationale. The normative specification lives in the pages linked below.

## Problem

The Mehr wire format originally used a fixed 484-byte maximum packet size — constrained by LoRa's duty-cycle limits. This wastes 68–95% of WiFi/Ethernet frame capacity and limits throughput on high-bandwidth links.

Three questions drove this design:

1. Can nodes probe a route's bandwidth and maximum packet size?
2. Should the protocol support variable-size packets that adapt to the path?
3. Does designing around LoRa's tiny MTU hurt performance on higher-bandwidth transports?

## Decision

**Yes to all three.** The protocol defines three transport classes (Constrained 484 B, Standard 1,500 B, Bulk 4,096 B) negotiated per-link via `LinkCapabilities`. Path MTU propagates passively through `bottleneck_mtu` in CompactPathCost announces. Active probing is opt-in and rate-limited.

Fragmentation is deferred — application-layer chunking (MHR-Store 4 KB chunks) is simpler and avoids reassembly buffer pressure on constrained devices.

## Key Trade-offs

| Choice | Benefit | Cost |
|--------|---------|------|
| Transport classes instead of global MTU | 3–8.5× throughput on fast links | Per-link negotiation complexity |
| Passive MTU via announces | Zero additional bandwidth | 1 extra byte per announce |
| Active probing opt-in | Real-time path measurement | Bandwidth cost; rate-limited to 1/min |
| Deferred fragmentation | Simpler, no reassembly buffers | Cross-transport paths (WiFi→LoRa→WiFi) must size to bottleneck |
| LoRa retains fixed-size padding | Traffic analysis resistance on RF | No variable-size benefit on constrained links |

## Specified In

| Topic | Specification Page |
|-------|-------------------|
| Transport classes, LinkCapabilities, Path MTU | [Physical Transport — Transport Classes](/docs/L0-physical/physical-transport#transport-classes-and-variable-packet-sizes) |
| `bottleneck_mtu` in CompactPathCost | [Network Protocol — CompactPathCost](/docs/L1-network/network-protocol#mehr-extension-compact-path-cost) |
| Active route probing | [Network Protocol — Route Probing](/docs/L1-network/network-protocol#route-probing) |
| PacketTooBig signal | [Physical Transport — Path MTU Behavior](/docs/L0-physical/physical-transport#path-mtu-behavior) |
| Security considerations | [Physical Transport — Security](/docs/L0-physical/physical-transport#security-considerations) |
| FAQ | [Physical Transport — FAQ](/docs/L0-physical/physical-transport#frequently-asked-questions) |

---

### Design Rationale: Bulk Transfer Pre-Negotiation
<!-- Source: docs/development/bulk-transfer-negotiation.md -->

# Design Rationale: Bulk Transfer Pre-Negotiation

> **Status**
**Specified in v1.0.** This page summarizes the design rationale. The normative specification lives in the pages linked below.

## Problem

Two related questions:

1. **Does route probing expose the sender's identity to the relay chain?** — Probe responses must travel back; does this leak who initiated the probe?
2. **Can we pre-negotiate an entire bulk transfer?** — Reserve bandwidth, agree on cost, and stream data with reduced per-packet overhead?

## Decisions

### Probe Anonymity

**No exposure.** Reverse-path routing means each relay only knows its immediate neighbors, not the probe originator. The response follows cached forwarding entries (`destination_hash + probe_id` → incoming interface), which expire after `3 × worst_latency_ms`. This is identical to the anonymity model for regular data packets — no source address in the packet.

### Bandwidth Reservation

**Yes — hop-by-hop propagation preserves anonymity.** The sender negotiates only with its direct neighbor, who independently propagates the reservation to the next hop. The sender never learns the path structure. Key design choices:

| Choice | Rationale |
|--------|-----------|
| Progressive escrow (10% upfront, per-chunk) | Aligns incentives — relay must deliver to earn. Full prepayment creates moral hazard. |
| VRF bypass during reservations | Eliminates ~666K VRF ops per GB; per-chunk deterministic payment is cheaper |
| No `hop_count` in commitment | Prevents sender from learning path length (deanonymization risk) |
| 60s inactivity = non-refundable escrow | Anti-DoS: bandwidth squatting costs real MHR |
| `allow_reroute` flag | Relay-initiated renegotiation if a ≥25% cheaper or ≥50% faster path appears |

### When Reservations vs. Stochastic Relay

| Transfer size | Recommendation |
|---------------|----------------|
| < 100 KB | Stochastic (default) |
| 100 KB – 1 MB | Either |
| 1 MB – 100 MB | Reservation beneficial |
| > 100 MB | Reservation strongly recommended |
| > 1 GB | Reservation + LargestMTU policy |

## Specified In

| Topic | Specification Page |
|-------|-------------------|
| Probe response routing | [Network Protocol — Probe Response Routing](/docs/L1-network/network-protocol#probe-response-routing) |
| Bandwidth reservation wire format | [Network Protocol — Bandwidth Reservation](/docs/L1-network/network-protocol#bandwidth-reservation) |
| Progressive escrow payment model | [Payment Channels — Reservation Payment](/docs/L3-economics/payment-channels#reservation-payment-progressive-escrow) |
| Reservation as capability agreement | [Marketplace Agreements — Bandwidth Reservations](/docs/L4-marketplace/agreements#bandwidth-reservations-as-agreements) |
| Security considerations | [Network Protocol — Security](/docs/L1-network/network-protocol#security-considerations) |
| FAQ | [Network Protocol — FAQ](/docs/L1-network/network-protocol#frequently-asked-questions) |
| Protocol constants | [Specification — Protocol Constants](../specification#protocol-constants) |

---
